---
title: "clearBoxDE - post deduplication"
author: "Melanie Smith"
date: "8 July 2024"
output: html_document
---

# Load required libraries
```{r load Libraries, warning=FALSE}

# Clean the environment
rm(list = ls(all.names = TRUE)) # will clear all objects including hidden objects
gc() # free up memory and report the memory usage

library(plyr)
library(reshape2)
library(dplyr)
library(tidyr)
library(knitr)
library(stringr)
library(edgeR)
library(readxl)
library(readr)
library(magrittr)
library(tibble)
library(ggplot2)
library(patchwork)
library(ggbeeswarm)
library(ggrepel)
library(pheatmap)

library(clusterProfiler)
library(org.Hs.eg.db)
library(AnnotationDbi)


# set project directory
projectDir <- "/home/smit1924/preeclampsia_sex_chromosome_informed"
# projectDir <- "/Users/pillmaka/Desktop/Melanie/drive-download"

# input files
counts_geneID_file <- file.path(projectDir, "deduplicated_clearBox/readCounts/deduplicated_s2_readCounts.txt")

gene_info_file <- file.path(projectDir, "clearBoxCleanData/gencode_v29_gene_id_symbol_chr_biotype.csv")
metadata_file <- file.path(projectDir, "clearBoxRawData/cleanSampleMetadata.csv")
input_SCOPE_STOP_cust_birthwgt_file <- file.path(projectDir, "deduplicated_clearBox/rawData/SCOPE_STOP_cust_birthwgt.csv")
input_gene_lists_file <- file.path(projectDir, "deduplicated_clearBox/rawData/gene_lists.xlsx")

# set the output directory
outdir <- file.path(projectDir, "deduplicated_clearBox/output/58_sample_noCovariate")

# output files
outDesignMatrix_file <- file.path(outdir, "designMatrix.csv")
output_spreadsheet_file <- file.path(outdir, "combined_allTable.csv")
output_pValue_file <- file.path(outdir, "pValue_DE.csv")
output_log2CPM_file <- file.path(outdir, "log2CPM.csv")
output_dgelist_58_file <- file.path(outdir, "filt_norm_dgelist_58.rds")
output_gene_wise_bcv_results_male_file <- file.path(outdir, "dedup_gene_wise_bcv_results_male.csv")
output_gene_wise_bcv_results_female_file <- file.path(outdir, "dedup_gene_wise_bcv_results_female.csv")
output_rawCounts_file <- file.path(outdir, "rawCounts.txt")

# set figure files
output_librarySize_file <- file.path(outdir, "deduplicated_librarySizePlot.png")
output_mds_file <- file.path(outdir, "deduplicated_58_mds.png")

dir.create(outdir)

# set max digits
options(digits=3)

# set filtering criteria
filterCPM <- 2
numSamples <- 5

```

# Import all input data tables
## Raw Counts
```{r}
# import the counts table
# counts are annotated to GRCh38
rawCounts_deduplicated <- read.delim(file = counts_geneID_file) %>%
  as.data.frame()
# tidy up the column names
colnames(rawCounts_deduplicated) <- gsub("X.media.sf_D_DRIVE.VM_Projects.20240619_deduplicateBams.deduplicated_data.|_marked_duplicates.bam|_T.*|_",
                                 "",
                                 colnames(rawCounts_deduplicated))

```

## Gene information and sample metadata
```{r}

## Metadata
metadata <- read_csv(file = metadata_file)

birthWgtCentile <- read_csv(file = input_SCOPE_STOP_cust_birthwgt_file)
# Transforming birthWgtCentile and creating the new column 'samplename'
birthWgtCentile <- birthWgtCentile %>%
  mutate(
    samplename = case_when(
      Study == "SCOPE" ~ "SCP",
      Study == "STOP" ~ "STP",
      TRUE ~ ""  # Fallback for other cases if necessary
    ),
    samplename = paste0(samplename, sprintf("%04d", Study.ID))
  )

# View the transformed data
head(birthWgtCentile)

## Gene ID versus GeneSymbol
gene_info <- read_csv(file = gene_info_file)

## Gene ID versus GeneSymbol
gene_info <- read_csv(file = gene_info_file)
gene_info <- gene_info[!duplicated(gene_info$ensembl_gene_id), ]

# Gene lists from Julie with TFs and SFs
gene_lists <- read_excel(input_gene_lists_file)

```

# Metadata table for the paper

```{r}


summary_table <- metadata %>%
  dplyr::left_join(., birthWgtCentile[,c("samplename", "Birthweight_centile")]) %>%
  group_by(sex_outcome, Sex) %>%
  summarise(
    # Maternal Age
    `Maternal Age (Mean ± SD)` = sprintf("%.1f ± %.1f", 
                                         mean(maternalAge, na.rm = TRUE), 
                                         sd(maternalAge, na.rm = TRUE)),
    
    # BMI
    `BMI (Mean ± SD)` = sprintf("%.1f ± %.1f", 
                                mean(BMI, na.rm = TRUE), 
                                sd(BMI, na.rm = TRUE)),
    
    # Gestational Age
    `Gestational Age (Mean ± SD)` = sprintf("%.1f ± %.1f", 
                                            mean(GestationalAge, na.rm = TRUE), 
                                            sd(GestationalAge, na.rm = TRUE)),
    
    # Birthweight
    `Birthweight (g) (Mean ± SD)` = sprintf("%.1f ± %.1f", 
                                            mean(Birthweight, na.rm = TRUE), 
                                            sd(Birthweight, na.rm = TRUE)),
    # Birthweight Centile
    `Birthweight Centile (Mean ± SD)` = sprintf("%.1f ± %.1f", 
                                            mean(Birthweight_centile, na.rm = TRUE), 
                                            sd(Birthweight_centile, na.rm = TRUE)),
                                            
    # Sample Size
    `N` = n()
  ) %>%
  ungroup()

# Optional: Print the table
print(t(summary_table[2,]))

# Optional: Create a formatted kable table
kable(t(summary_table))

```

# Metadata compare between groups
- Not sure if we want this for the paper but here I will test te see if there are differences between groups for the metadata features we are interested in

```{r}

metadata_centile <- metadata %>%
  dplyr::left_join(., birthWgtCentile[,c("samplename", "Birthweight_centile")])

```

## Maternal Age

```{r}

#-------------------------------------------------------------------------------#
# Test maternal age - males
#-------------------------------------------------------------------------------#

# First, check normality and equal variance assumptions
# Shapiro-Wilk test for normality
shapiro_m_pe <- shapiro.test(metadata_centile$maternalAge[metadata_centile$sex_outcome == "M_PE"])
shapiro_m_control <- shapiro.test(metadata_centile$maternalAge[metadata_centile$sex_outcome == "M_Control"])

# Variance test
var_test_m <- var.test(maternalAge ~ sex_outcome, 
                     data = metadata_centile, 
                     subset = sex_outcome %in% c("M_PE", "M_Control"))

# Parametric test (if data is normally distributed)
t_test_result_m <- t.test(maternalAge ~ sex_outcome, 
                        data = metadata_centile,
                        subset = sex_outcome %in% c("M_PE", "M_Control"))

# Mean difference
mean_difference_m <- t_test_result_m$estimate[2] - t_test_result_m$estimate[1]

# P-value
p_value <- t_test_result_m$p.value

#-------------------------------------------------------------------------------#
# Test maternal age - females
#-------------------------------------------------------------------------------#

# First, check normality and equal variance assumptions
# Shapiro-Wilk test for normality
shapiro_f_pe <- shapiro.test(metadata_centile$maternalAge[metadata_centile$sex_outcome == "F_PE"])
shapiro_f_control <- shapiro.test(metadata_centile$maternalAge[metadata_centile$sex_outcome == "F_Control"])

# Variance test
var_test_f <- var.test(maternalAge ~ sex_outcome, 
                     data = metadata_centile, 
                     subset = sex_outcome %in% c("F_PE", "F_Control"))

# Parametric test (if data is normally distributed)
t_test_result_f <- t.test(maternalAge ~ sex_outcome, 
                        data = metadata_centile,
                        subset = sex_outcome %in% c("F_PE", "F_Control"))

# Mean difference
mean_difference_f <- t_test_result_f$estimate[2] - t_test_result_f$estimate[1]

# P-value
p_value_f <- t_test_result_f$p.value


```

## Maternal BMI

```{r}

#-------------------------------------------------------------------------------#
# Test maternal bmi - males
#-------------------------------------------------------------------------------#

# First, check normality and equal variance assumptions
# Shapiro-Wilk test for normality
shapiro_m_pe <- shapiro.test(metadata_centile$BMI[metadata_centile$sex_outcome == "M_PE"])
shapiro_m_control <- shapiro.test(metadata_centile$BMI[metadata_centile$sex_outcome == "M_Control"])

# Variance test
var_test_m <- var.test(BMI ~ sex_outcome, 
                     data = metadata_centile, 
                     subset = sex_outcome %in% c("M_PE", "M_Control"))

# Parametric test (if data is normally distributed)
t_test_result_m <- t.test(BMI ~ sex_outcome, 
                        data = metadata_centile,
                        subset = sex_outcome %in% c("M_PE", "M_Control"))

# Mean difference
mean_difference_m <- t_test_result_m$estimate[2] - t_test_result_m$estimate[1]

# P-value
p_value <- t_test_result_m$p.value

#-------------------------------------------------------------------------------#
# Test maternal bmi - females
#-------------------------------------------------------------------------------#

# First, check normality and equal variance assumptions
# Shapiro-Wilk test for normality
shapiro_f_pe <- shapiro.test(metadata_centile$BMI[metadata_centile$sex_outcome == "F_PE"])
shapiro_f_control <- shapiro.test(metadata_centile$BMI[metadata_centile$sex_outcome == "F_Control"])

# Variance test
var_test_f <- var.test(BMI ~ sex_outcome, 
                     data = metadata_centile, 
                     subset = sex_outcome %in% c("F_PE", "F_Control"))

# Parametric test (if data is normally distributed)
t_test_result_f <- t.test(BMI ~ sex_outcome, 
                        data = metadata_centile,
                        subset = sex_outcome %in% c("F_PE", "F_Control"))

# Mean difference
mean_difference_f <- t_test_result_f$estimate[2] - t_test_result_f$estimate[1]

# P-value
p_value_f <- t_test_result_f$p.value


```

## Gestational Age

```{r}

#-------------------------------------------------------------------------------#
# Test gestational age - males
#-------------------------------------------------------------------------------#

# First, check normality and equal variance assumptions
# Shapiro-Wilk test for normality
shapiro_m_pe <- shapiro.test(metadata_centile$GestationalAge[metadata_centile$sex_outcome == "M_PE"])
shapiro_m_control <- shapiro.test(metadata_centile$GestationalAge[metadata_centile$sex_outcome == "M_Control"])

# Variance test
var_test <- var.test(GestationalAge ~ sex_outcome, 
                     data = metadata_centile, 
                     subset = sex_outcome %in% c("M_PE", "M_Control"))

# Non-parametric test (if data is not normally distributed)
wilcox_test_result <- wilcox.test(GestationalAge ~ sex_outcome,
                                  data = metadata_centile,
                                  subset = sex_outcome %in% c("M_PE", "M_Control"))

#-------------------------------------------------------------------------------#
# Test gestational age - females
#-------------------------------------------------------------------------------#

# First, check normality and equal variance assumptions
# Shapiro-Wilk test for normality
shapiro_f_pe <- shapiro.test(metadata_centile$GestationalAge[metadata_centile$sex_outcome == "F_PE"])
shapiro_f_control <- shapiro.test(metadata_centile$GestationalAge[metadata_centile$sex_outcome == "F_Control"])

# Variance test
var_test_f <- var.test(GestationalAge ~ sex_outcome, 
                     data = metadata_centile, 
                     subset = sex_outcome %in% c("F_PE", "F_Control"))

# Non-parametric test (if data is not normally distributed)
wilcox_test_result_f <- wilcox.test(GestationalAge ~ sex_outcome,
                                  data = metadata_centile,
                                  subset = sex_outcome %in% c("F_PE", "F_Control"))

```

## Birthweight

```{r}

#-------------------------------------------------------------------------------#
# Test birthweight - males
#-------------------------------------------------------------------------------#

# First, check normality and equal variance assumptions
# Shapiro-Wilk test for normality
shapiro_m_pe <- shapiro.test(metadata_centile$Birthweight[metadata_centile$sex_outcome == "M_PE"])
shapiro_m_control <- shapiro.test(metadata_centile$Birthweight[metadata_centile$sex_outcome == "M_Control"])

# Variance test
var_test <- var.test(Birthweight ~ sex_outcome, 
                     data = metadata_centile, 
                     subset = sex_outcome %in% c("M_PE", "M_Control"))

# Non-parametric test (if data is not normally distributed)
wilcox_test_result <- wilcox.test(Birthweight ~ sex_outcome,
                                  data = metadata_centile,
                                  subset = sex_outcome %in% c("M_PE", "M_Control"))

#-------------------------------------------------------------------------------#
# Test birthweight - females
#-------------------------------------------------------------------------------#

# First, check normality and equal variance assumptions
# Shapiro-Wilk test for normality
shapiro_f_pe <- shapiro.test(metadata_centile$Birthweight[metadata_centile$sex_outcome == "F_PE"])
shapiro_f_control <- shapiro.test(metadata_centile$Birthweight[metadata_centile$sex_outcome == "F_Control"])

# Variance test
var_test_f <- var.test(Birthweight ~ sex_outcome, 
                     data = metadata_centile, 
                     subset = sex_outcome %in% c("F_PE", "F_Control"))

# Non-parametric test (if data is not normally distributed)
wilcox_test_result_f <- wilcox.test(Birthweight ~ sex_outcome,
                                  data = metadata_centile,
                                  subset = sex_outcome %in% c("F_PE", "F_Control"))

```

## Birthweight Centile

```{r}

#-------------------------------------------------------------------------------#
# Test birthweight centile - males
#-------------------------------------------------------------------------------#

# First, check normality and equal variance assumptions
# Shapiro-Wilk test for normality
shapiro_m_pe <- shapiro.test(metadata_centile$Birthweight_centile[metadata_centile$sex_outcome == "M_PE"])
shapiro_m_control <- shapiro.test(metadata_centile$Birthweight_centile[metadata_centile$sex_outcome == "M_Control"])

# Variance test
var_test_m <- var.test(Birthweight_centile ~ sex_outcome, 
                     data = metadata_centile, 
                     subset = sex_outcome %in% c("M_PE", "M_Control"))

# Parametric test (if data is normally distributed)
t_test_result_m <- t.test(Birthweight_centile ~ sex_outcome, 
                        data = metadata_centile,
                        subset = sex_outcome %in% c("M_PE", "M_Control"))

# Mean difference
mean_difference_m <- t_test_result_m$estimate[2] - t_test_result_m$estimate[1]

# P-value
p_value <- t_test_result$p.value

#-------------------------------------------------------------------------------#
# Test Birthweight centile - females
#-------------------------------------------------------------------------------#

# First, check normality and equal variance assumptions
# Shapiro-Wilk test for normality
shapiro_f_pe <- shapiro.test(metadata_centile$Birthweight_centile[metadata_centile$sex_outcome == "F_PE"])
shapiro_f_control <- shapiro.test(metadata_centile$Birthweight_centile[metadata_centile$sex_outcome == "F_Control"])

# Variance test
var_test_f <- var.test(Birthweight_centile ~ sex_outcome, 
                     data = metadata_centile, 
                     subset = sex_outcome %in% c("F_PE", "F_Control"))

# Parametric test (if data is normally distributed)
t_test_result_f <- t.test(Birthweight_centile ~ sex_outcome, 
                        data = metadata_centile,
                        subset = sex_outcome %in% c("F_PE", "F_Control"))

# Mean difference
mean_difference_f <- t_test_result_f$estimate[2] - t_test_result_f$estimate[1]

# P-value
p_value_f <- t_test_result_f$p.value


```

# Plot the raw library sizes

```{r}

## library size information for the paper
# calculate the median raw library size pre-deduplication
median_lib_size <- rawCounts_deduplicated %>%
  tibble::column_to_rownames("Geneid") %>%
  dplyr::select(all_of(metadata$samplename)) %>%
  colSums() %>%
  median()


data.frame(colSums(rawCounts_deduplicated[, -1])) %>%
  # rename(lib.size = colSums.rawCounts_deduplicated....1..) %>%
  setNames("lib.size") %>%
  tibble::rownames_to_column("samplename") %>%
  mutate(color = case_when(
    lib.size < 5000000 ~ "red",
    lib.size >= 5000000 & lib.size < 10000000 ~ "blue",
    lib.size >= 10000000 ~ "darkgreen"
  )) %>%
  dplyr::filter(!samplename %in% c("SCP3492", "SCP4010", "SCP4060")) %>%
  ggplot(aes(x = reorder(samplename, -lib.size), y = lib.size, fill = color)) +
  geom_bar(stat = "identity") +
  geom_hline(yintercept = 5000000, linetype = "dashed", color = "red") +
  geom_hline(yintercept = 10000000, linetype = "dashed", color = "darkgreen") +
  labs(y = "Library size (total number of mapped and quantified reads)",
       x = "Samplename") +
  scale_fill_identity() +
  coord_flip() +
  ggtitle("Deduplicated Library Size")
# ggsave(filename = output_librarySize_file,
#        width = 7,
#        height = 7,
#        units = "in",
#        dpi = 150)

```

# Establish DGElist object

```{r}
# drop the samples not required for this analysis
counts <- rawCounts_deduplicated %>%
  tibble::column_to_rownames("Geneid")
counts <- counts[, metadata$samplename]

# drop rows with zero in all columns
counts <- counts[rowSums(counts[])>0,] %>%
  tibble::rownames_to_column("ensembl_gene_id")

# add the hgnc gene symbol, chromosome and biotype to the counts matrix
counts_hgnc <- dplyr::left_join(counts, gene_info, by = "ensembl_gene_id") %>%
  dplyr::select(., ensembl_gene_id, ensembl, hgnc_symbol, seqnames, gene_type, everything())
dim(counts_hgnc) # 43423 63

# drop rows with NAs introduced in the join
counts_hgnc_clean <- counts_hgnc %>%
  filter(!is.na(ensembl))
dim(counts_hgnc_clean) # 42645 63

# establish the DGEList
dge_list_obj <- DGEList(counts = counts_hgnc_clean %>%
                          tibble::column_to_rownames("ensembl") %>%
                          dplyr::select(., -hgnc_symbol, -ensembl_gene_id, -seqnames, -gene_type),
                        samples = metadata,
                        group = metadata$group,
                        genes = counts_hgnc_clean %>% dplyr::select(ensembl, hgnc_symbol, seqnames, gene_type))

## Save a table of raw counts
write.table(dge_list_obj$counts,
            file = output_rawCounts_file,
            sep = "\t",
            row.names = TRUE,
            col.names = NA,  # This ensures proper alignment with rownames
            quote = FALSE)

```

# Filter biological noise and plot

```{r}

# new df of unfiltered cpm for the reduced DGEList
preFilterCPM <- cpm(dge_list_obj)

# remove low expressed genes (filterCPM in numSamples PE)
keep.exprs <- rowSums(preFilterCPM > filterCPM) >= numSamples

# Perform the filtering step and recalculate the TMM normalisation factors for each library.
dge_list_obj <- dge_list_obj[keep.exprs,,keep.lib.sizes = FALSE]

dim(dge_list_obj)

```

# TMM normalisation
```{r}
# calculate normalisation factors and apply to the DGEList object
dge_list_obj <- calcNormFactors(dge_list_obj,
                                method = "TMM")

# # set the new factor levels
sex_outcome_levels <- c("F_Control", "M_Control", "F_PE", "M_PE")
dge_list_obj$samples$sex_outcome <- factor(dge_list_obj$samples$sex_outcome, levels=sex_outcome_levels)

## save the filtered and normalised DGEList object
# saveRDS(dge_list_obj,
#         file = output_dgelist_58_file)
```

# Clustering analysis

```{r}
# Load required libraries
library(mclust)  # For model-based clustering
library(tidyverse)  # For data manipulation


# Ensure input is a valid DGEList object
if (!inherits(dge_list_obj, "DGEList")) {
  stop("Input 'dge_list_obj' must be a valid DGEList object.")
}

# 3. Transform counts to log-CPM (log Counts Per Million)
logCPM <- edgeR::cpm(dge_list_obj, log = TRUE)  # Log-transform for normalization

# 4. Perform model-based clustering using mclust
# Mclust automatically selects the best number of clusters and model
mclust_result <- Mclust(t(logCPM))

# View the clustering summary
summary(mclust_result)

# 5. Visualize clustering results
# (a) Plot the model-based clustering
plot(mclust_result, what = "classification")  # Cluster assignment visualization
plot(mclust_result, what = "BIC")             # BIC values for model selection

# (b) Visualize clusters in PCA space
pca <- prcomp(t(logCPM))  # Perform PCA on the transposed matrix
clusters <- as.factor(mclust_result$classification)  # Cluster assignments


pca_df <- data.frame(PC1 = pca$x[, 1],
                     PC2 = pca$x[, 2],
                     Cluster = clusters,
                     samplename = rownames(pca$x)) %>%
  dplyr::left_join(., metadata[, c("samplename", "sex_outcome")], by = "samplename")

ggplot(pca_df, aes(x = PC1,
                   y = PC2,
                   color = Cluster,
                   shape = sex_outcome)) +
  geom_point(size = 3) +
  geom_text_repel(aes(label = samplename),  # Use geom_text_repel for non-overlapping labels
                  size = 3,             # Text size
                  max.overlaps = Inf,   # Show all labels, even if overlapping
                  show.legend = FALSE) + 
  labs(title = "PCA of Clusters", x = "PC1", y = "PC2") +
  theme_minimal()

```

## Correlate PCA and Mclust

```{r}
input_cibersortx_post_dedup_proportions_file <- file.path(projectDir, "deduplicated_clearBox/cibersortx_output/CIBERSORTx_Job10_Adjusted.txt")

# import the post deduplication cibersortx proportions
cibersort_proportions <- read.table(file = input_cibersortx_post_dedup_proportions_file,
                               header = TRUE,
                               sep = "\t") %>%
  dplyr::select(samplename = Mixture, everything()) %>%
  # remove the trailing "_dedup" from the samplename
  dplyr::mutate(samplename = gsub("_dedup$", "", samplename)) %>%
  # remove the stats we don't need
  dplyr::select(., -'P.value', -'Correlation', -'RMSE') %>%
  # keep only the 58 final samples
  inner_join(metadata[, c("samplename")], by = "samplename")

# Assuming your data is in a dataframe called 'cibersort_data'
# where columns are cell types and rows are samples

# Create a summary dataframe
cibersort_summary_table <- data.frame(
  Cell_Type = colnames(cibersort_proportions[, -1]),
  Mean = sapply(cibersort_proportions[, -1], mean, na.rm = TRUE),
  SD = sapply(cibersort_proportions[, -1], sd, na.rm = TRUE)
)

# Format to keep only necessary decimal places
cibersort_summary_table$Mean <- round(cibersort_summary_table$Mean, 4)
cibersort_summary_table$SD <- round(cibersort_summary_table$SD, 4)

# Print or save the table
print(cibersort_summary_table)

# Optional: write to CSV
write.csv(cibersort_summary_table, "cell_type_proportions_summary.csv", row.names = FALSE)

# Merge Mclust cluster information with cell type proportions
cluster_proportions <- data.frame(
  samplename = rownames(pca$x),
  Cluster = as.factor(mclust_result$classification)
) %>%
  left_join(cibersort_proportions, by = "samplename")

# Automatically select cell type columns
cell_types <- names(cibersort_proportions)[!(names(cibersort_proportions) %in% c("samplename"))]

# Prepare results storage
anova_and_tukey_results <- list()

# Perform ANOVA and Tukey's HSD for each cell type
for(cell_type in cell_types) {
  # ANOVA
  aov_result <- aov(as.formula(paste(cell_type, "~ Cluster")), data = cluster_proportions)
  
  # Tukey's HSD test
  tukey_result <- TukeyHSD(aov_result)
  
  # Prepare results
  anova_summary <- summary(aov_result)
  p_value <- anova_summary[[1]][["Pr(>F)"]][1]
  
  # Store results
  anova_and_tukey_results[[cell_type]] <- list(
    ANOVA_p_value = p_value,
    Tukey_HSD = tukey_result$Cluster
  )
}

# Prepare summary dataframe with individual adjusted p-values
summary_results <- lapply(names(anova_and_tukey_results), function(cell_type) {
  # Get Tukey HSD results
  tukey_df <- as.data.frame(anova_and_tukey_results[[cell_type]]$Tukey_HSD)
  tukey_df$comparison <- rownames(tukey_df)
  tukey_df$cell_type <- cell_type
  tukey_df$anova_p_value <- anova_and_tukey_results[[cell_type]]$ANOVA_p_value
  
  return(tukey_df)
})

# Combine results
final_results <- do.call(rbind, summary_results)

# Adjust p-values for multiple comparisons separately for each cell type
final_results_adjusted <- do.call(rbind, lapply(split(final_results, final_results$cell_type), function(cell_type_df) {
  cell_type_df$adjusted_p_value <- p.adjust(cell_type_df$`p adj`, method = "BH")
  return(cell_type_df)
}))

# Filter for statistically significant comparisons
significant_results <- final_results_adjusted[final_results_adjusted$adjusted_p_value < 0.05, ]

# Print significant results
print("Statistically Significant Cluster Differences:")
print(significant_results)
# Visualization of significant differences
#output directory
correlation_plots <- file.path(projectDir, "deduplicated_clearBox/output/correlation_plots")

# Boxplot for cell types with significant cluster differences
for(cell_type in unique(significant_results$cell_type)) {
  p <- ggplot(cluster_proportions, aes_string(x = "Cluster", y = cell_type, fill = "Cluster")) +
    geom_boxplot() +
    labs(title = paste("Cell Type Proportions for", cell_type),
         x = "Cluster", y = "Proportion") +
    theme_minimal()
  
  ggsave(filename = paste0(correlation_plots, "/", cell_type, "_cluster_boxplot.jpg"), plot = p, 
         width = 10, height = 6, dpi = 300)
}


# Correlation with PCA loadings
# Extract first few principal components
pca_loadings <- data.frame(
  samplename = rownames(pca$x),
  PC1 = pca$x[, 1],
  PC2 = pca$x[, 2]
) %>%
  left_join(cibersort_proportions, by = "samplename")

# Compute correlations between PCA loadings and cell type proportions
cor_results <- lapply(cell_types, function(cell_type) {
  # Correlation with PC1 and PC2
  cor_pc1 <- cor.test(pca_loadings$PC1, pca_loadings[[cell_type]])
  cor_pc2 <- cor.test(pca_loadings$PC2, pca_loadings[[cell_type]])
  
  data.frame(
    CellType = cell_type,
    PC1_correlation = cor_pc1$estimate,
    PC1_p_value = cor_pc1$p.value,
    PC2_correlation = cor_pc2$estimate,
    PC2_p_value = cor_pc2$p.value
  )
})

# Combine correlation results
cor_df <- do.call(rbind, cor_results)
cor_df$PC1_adjusted_p_value <- p.adjust(cor_df$PC1_p_value, method = "BH")
cor_df$PC2_adjusted_p_value <- p.adjust(cor_df$PC2_p_value, method = "BH")

# Print significant correlations
print("Significant Correlations with PCA Loadings:")
print(cor_df[cor_df$PC1_adjusted_p_value < 0.05 | cor_df$PC2_adjusted_p_value < 0.05, ])

# Scatter plots of significant correlations
significant_cell_types <- cor_df$CellType[cor_df$PC1_adjusted_p_value < 0.05 | cor_df$PC2_adjusted_p_value < 0.05]

#output directory
correlation_plots <- file.path(projectDir, "deduplicated_clearBox/output/correlation_plots")

for(cell_type in significant_cell_types) {
  # PC1 correlation plot
  p1 <- ggplot(pca_loadings, aes_string(x = "PC1", y = cell_type)) +
    geom_point() +
    geom_smooth(method = "lm") +
    labs(title = paste("PC1 vs", cell_type),
         x = "PC1", y = paste(cell_type, "Proportion")) +
    theme_minimal()
  
  # PC2 correlation plot
  p2 <- ggplot(pca_loadings, aes_string(x = "PC2", y = cell_type)) +
    geom_point() +
    geom_smooth(method = "lm") +
    labs(title = paste("PC2 vs", cell_type),
         x = "PC2", y = paste(cell_type, "Proportion")) +
    theme_minimal()
  
  # Save plots as PNG files
  ggsave(
    filename = file.path(correlation_plots, paste0(cell_type, "_PC1_correlation.jpg")), 
    plot = p1, 
    width = 10, 
    height = 6, 
    dpi = 300
  )
  
  ggsave(
    filename = file.path(correlation_plots, paste0(cell_type, "_PC2_correlation.jpg")), 
    plot = p2, 
    width = 10, 
    height = 6, 
    dpi = 300
  )
}
```


# Plot MDS
## base
```{r}
# define colours for each sex_outcome group
sex_outcome_levels <- levels(as.factor(dge_list_obj$samples$sex_outcome))
colors <- rainbow(length(sex_outcome_levels))
# create a colour vector that matches the rows in the DGElist object
col_vector <- colors[as.numeric(as.factor(dge_list_obj$samples$sex_outcome))]

# save as png
# png(file = output_mds_file,
#     width = 12,
#     height = 9,
#     units = "in",
#     res = 150)
# Create the MDS plot with customizations
limma::plotMDS(dge_list_obj, col=col_vector, labels=dge_list_obj$samples$samplename, main="MDS Plot 58 samples - deduplicated")
legend("topright", legend=sex_outcome_levels, col=colors, pch=20, xpd=TRUE, inset=c(0.01, -0.1))
# dev.off()
```

## ggplot
```{r}
# Calculate MDS coordinates
mds_result <- plotMDS(dge_list_obj, plot = FALSE)

# Create data frame for ggplot
mds_data <- data.frame(
  x = mds_result$x,
  y = mds_result$y,
  sex_outcome = dge_list_obj$samples$sex_outcome,
  samplename = dge_list_obj$samples$samplename
)

# Create the ggplot
p <- ggplot(mds_data, aes(x = x, y = y, colour = sex_outcome)) +
  geom_point(size = 5) +
    scale_color_manual(values = c("palegreen3", "#004000",  "plum3", "#2A0052")) +
  labs(
    # title = "MDS Plot 58 samples - deduplicated",
    x = paste0("Leading logFC dim 1 (", round(mds_result$var.explained[1]*100, 1), "%)"),
    y = paste0("Leading logFC dim 2 (", round(mds_result$var.explained[2]*100, 1), "%)"),
    color = "Fetal Sex and Outcome"
    ) +
  theme_classic() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14),
    legend.position = "none",
    legend.title = element_text(size = 12,
                                colour = "black",
                                face = "bold"),
    legend.text = element_text(size = 12,
                               colour = "black",
                               face = "bold")
    )

# Display the plot
print(p)

# Save the plot (uncomment to save)
ggsave(filename = output_mds_file,
       plot = p,
       width = 9,
       height = 6,
       units = "in",
       dpi = 300)
```

# Sex-specific BCV

```{r}
# vector of only male sample names
males <- dplyr::filter(dge_list_obj$samples, Sex == "M")[, "samplename"]
# subset DGEList to contain only males
y_male <- dge_list_obj[, males]
# calculate and plot BCV for male samples only
y_male <- estimateCommonDisp(y_male,
                             verbose = TRUE)
y_male <- estimateTrendedDisp(y_male)
y_male <- estimateTagwiseDisp(y_male)

# Extract gene-wise BCV values
gene_wise_bcv_male <- sqrt(y_male$tagwise.dispersion)

# Create a data frame with gene names and BCV values
bcv_table_male <- data.frame(
  Gene = rownames(y_male),
  BCV = gene_wise_bcv_male,
  AveExpr = y_male$AveLogCPM
)

# save the table to a CSV file:
# write.csv(bcv_table_male, file = output_gene_wise_bcv_results_male_file,
# row.names = FALSE)

# plot the BCVs
plotBCV(y_male,
        xlab = "Average log CPM",
        ylab = "Biological coefficient of variation - male",
        pch = 16,
        cex = 0.2,
        col.common = "red",
        col.trend = "blue",
        col.tagwise = "black")

# vector of only female sample names
females <- dplyr::filter(dge_list_obj$samples, Sex == "F")[, "samplename"]
# subset DGEList to contain only females
y_female <- dge_list_obj[, females]
# calculate and plot BCV for female samples only
y_female <- estimateCommonDisp(y_female,
                               verbose = TRUE)
y_female <- estimateTrendedDisp(y_female)
y_female <- estimateTagwiseDisp(y_female)
# Extract gene-wise BCV values
gene_wise_bcv_female <- sqrt(y_female$tagwise.dispersion)
# Create a data frame with gene names and BCV values
bcv_table_female <- data.frame(
  Gene = rownames(y_female),
  BCV = gene_wise_bcv_female,
  AveExpr = y_female$AveLogCPM
)

# save the table to a CSV file:
# write.csv(bcv_table_female, file = output_gene_wise_bcv_results_female_file,
# row.names = FALSE)

plotBCV(y_female,
        xlab = "Average log CPM",
        ylab = "Biological coefficient of variation - female",
        pch = 16,
        cex = 0.2,
        col.common = "red",
        col.trend = "blue",
        col.tagwise = "black")

plot(bcv_table_male$BCV, bcv_table_female$BCV)

# Density plot of the BCVs
# Add a column to each data frame to indicate the sex
bcv_table_male <- bcv_table_male %>%
  mutate(sex = "male")

bcv_table_female <- bcv_table_female %>%
  mutate(sex = "female")

# Combine the data frames
bcv_combined <- bind_rows(bcv_table_male, bcv_table_female)

# Create the density plot
ggplot(bcv_combined, aes(x = BCV,
                         fill = sex,
                         colour = sex)) +
  geom_density(alpha = 0.5) +
  labs(title = "Density Plot of BCV by Fetal Sex",
       x = "BCV",
       y = "Density") +
  theme_minimal()

```

# Estimate BCV (all samples together)
```{r}
dge_list_obj <- estimateCommonDisp(dge_list_obj,
                                   verbose=TRUE)
dge_list_obj <- estimateTrendedDisp(dge_list_obj)
dge_list_obj <- estimateTagwiseDisp(dge_list_obj)
# plot the BCV vs log2CPM
plotBCV(dge_list_obj)

# Extract gene-wise BCV values
gene_wise_bcv <- sqrt(dge_list_obj$tagwise.dispersion)

# Create a data frame with gene names and BCV values
bcv_table <- data.frame(
  Gene = rownames(dge_list_obj),
  BCV = gene_wise_bcv,
  AveExpr = dge_list_obj$AveLogCPM
)

# Sort the table by BCV (descending order)
bcv_table_sorted <- bcv_table[order(-bcv_table$BCV), ]

# View the top rows of the table
head(bcv_table_sorted)

# save the table to a CSV file:
# write.csv(bcv_table_sorted, file = "gene_wise_bcv_results.csv", row.names = FALSE)
```

# Calculate log2CPM and save table as .csv

```{r}
# # calculate the log2 CPM for all genes in all samples
# log2CPM <- edgeR::cpm(dge_list_obj, log = TRUE)
# 
# edgeR::cpm(dge_list_obj, log = TRUE) %>%
#   as.data.frame() %>%
#   tibble::rownames_to_column("ensembl") %>%
#   write_csv(., file = output_log2CPM_file,
#            col_names = TRUE)

# import the log2CPM file
log2CPM <- read_csv("/home/smit1924/preeclampsia_sex_chromosome_informed/deduplicated_clearBox/output/58_sample_noCovariate/log2CPM.csv")

# calculate the average log2 CPM for all genes by sex_outcome group
# Step 1: Convert log2CPM from wide to long format
log2CPM_long <- log2CPM %>%
  as.data.frame() %>%
  tidyr::pivot_longer(cols = -ensembl, names_to = "samplename", values_to = "Expression")

# Step 2: Merge with metadata to get 'sex_outcome' group
merged_data <- log2CPM_long %>%
  left_join(metadata[, c("samplename", "sex_outcome")], by = "samplename")  # Merge using sample names

# Step 3: Calculate average expression per gene for each 'sex_outcome' group
avg_expression_by_group <- merged_data %>%
  group_by(ensembl, sex_outcome) %>%
  summarize(AveExpr = mean(Expression, na.rm = TRUE), .groups = "drop")  # Mean log2CPM

# View the results
head(avg_expression_by_group)

# Step 4: Filter allTable_male for significant DE genes
allTable_male <- read_csv("/home/smit1924/preeclampsia_sex_chromosome_informed/deduplicated_clearBox/output/58_sample_noCovariate/allTable_male.csv")

significant_genes <- allTable_male %>%
  dplyr::filter(abs(logFC) >= 1, adj.P.Val < 0.05, AveExpr >=1) %>%
  dplyr::select(ensembl)  # Keep only the ensembl column for filtering

# Step 5: Filter avg_expression_by_group to keep only significant genes
filtered_avg_expr <- avg_expression_by_group %>%
  semi_join(significant_genes, by = "ensembl")

# View the filtered results
head(filtered_avg_expr)

filtered_avg_expr_wide <- filtered_avg_expr %>%
  tidyr::pivot_wider(names_from = sex_outcome, values_from = AveExpr)

# save a csv of the average logFC for each of the groups
write_csv(data.frame(filtered_avg_expr_wide),
          file = file.path(outdir, "averageLog2CPM.csv"),
          col_names = TRUE)
```

# Differential Expression
- covariates are either  
  - maternal age  
  - maternal BMI  
```{r}
## No covariates
#Create and write out design matrix
model_noCovariate <- '~0 + sex_outcome'
# establish the design matrix
design_sex_PE <- model.matrix(formula(model_noCovariate),
                              data = dge_list_obj$samples)
# make the column names a little nicer
colnames(design_sex_PE) <- c(sex_outcome_levels)

# # save a csv of the design matrix
# write_csv(data.frame(design_sex_PE) %>%
#             tibble::rownames_to_column("samplename"),
#           file = outDesignMatrix_file,
#           col_names = TRUE)
```

```{r}
# perform the voom
voom_sex_PE <- voom(dge_list_obj, design_sex_PE, plot = TRUE)

# fit the linear model
fit_sex_PE <- lmFit(voom_sex_PE, design_sex_PE)
```

## allTable and residuals for n=58 

```{r}
# perform bayesian adjustment
fit_sex_PE <- eBayes(fit_sex_PE)

# check the coefficients
full_model_coefficients <- fit_sex_PE$coefficients
saveRDS(full_model_coefficients,
        file = file.path(outdir, "full_model_coefficients.rds"))
dim(full_model_coefficients)

# summary table of the sex PE fit
summary(decideTests(fit_sex_PE,
                    adjust.method = "fdr",
                    p.value = 0.05))

# all DE results for the female_PE comparison
allTable_PE <- topTable(fit_sex_PE,
                             # coef = "female_PE",
                             n = Inf,
                             sort = "none")

```

## Sex-specific contrast, fit and residuals

```{r}
# set the contrasts - this makes it easier to "see" what we're testing
contrast_sex_PE <- makeContrasts(female_PE = F_PE-F_Control,
                                 male_PE = M_PE-M_Control,
                                 levels = design_sex_PE)
contrast_sex_PE

# fit a linear regression to the contrast questions
contrast_fit_sex_PE <- contrasts.fit(fit_sex_PE, contrast_sex_PE)

# perform bayesian adjustment
contrast_fit_sex_PE <- eBayes(contrast_fit_sex_PE)

# grab the residuals
res_post_dedup <- residuals(fit_sex_PE,voom_sex_PE)
# saveRDS(res_post_dedup,
#         file = file.path(outdir, "residuals.rds"))

# grab the fitted values
fitted_post_dedup <- fitted(fit_sex_PE)
# saveRDS(fitted_post_dedup,
#         file = file.path(outdir, "fitted_values.rds"))

# check the coefficients
coefficients <- contrast_fit_sex_PE$coefficients
# saveRDS(coefficients,
#         file = file.path(outdir, "coefficients.rds"))
dim(contrast_fit_sex_PE$coefficients)
```

```{r}
# summary table of the sex PE fit
summary(decideTests(contrast_fit_sex_PE,
                    adjust.method = "fdr",
                    p.value = 0.05))

# all DE results for the female_PE comparison
allTable_female_PE <- topTable(contrast_fit_sex_PE,
                             coef = "female_PE",
                             n = Inf,
                             sort = "p")
# create output files and save
# write_csv(allTable_female_PE,
#           file=file.path(outdir, "allTable_female.csv"))

# write_csv(allTable_female_PE,
#           file="/media/sf_D_DRIVE/VM_Projects/20240723_compare_pre_post_dedup/allTable_female_post_dedup.csv")


# all DE results for the male comparison
allTable_male_PE <- topTable(contrast_fit_sex_PE,
                             coef = "male_PE",
                             n = Inf,
                             sort = "p")
# write_csv(allTable_male_PE,
#           file=file.path(outdir, "allTable_male.csv"))

# write_csv(allTable_male_PE,
#           file="/media/sf_D_DRIVE/VM_Projects/20240723_compare_pre_post_dedup/allTable_male_post_dedup.csv")

topTable_male_pe <- topTable(contrast_fit_sex_PE,
                             coef = "male_PE",
                             n = Inf,
                             sort = "p",
                             p = 0.05,
                             adjust.method = "fdr")

# create output files and save
# write_csv(topTable_male_pe,
#           file="/home/smit1924/preeclampsia_sex_chromosome_informed/noCovariate_output/topTable_male_pe.csv")

# write out a few summary tables

# Count occurrences for both conditions in a single pipeline
seqname_counts <- allTable_male_PE %>%
  dplyr::filter(., adj.P.Val < 0.05) %>%
  mutate(condition = ifelse(logFC < 0, "down", "up")) %>%
  group_by(seqnames, condition) %>%
  summarise(count = n(), .groups = "drop")

# View the result
print(seqname_counts)

df <- left_join(allTable_female_PE %>% dplyr::select(-t, -P.Value, -B),
               allTable_male_PE %>% dplyr::select(-t, -P.Value, -B),
               by=c('hgnc_symbol', 'ensembl'),
          suffix=c("_F", "_M"))

coeff_and_sigma_df <- cbind(fit_sex_PE$coefficients, sigma=fit_sex_PE$sigma) %>%
  as.data.frame() %>%
  rownames_to_column(var="ensembl")

df <- left_join(coeff_and_sigma_df,
               df,
               by="ensembl")

# write_csv(df %>% relocate(hgnc_symbol, .after=ensembl),
#           file=output_spreadsheet_file)

df2 <- left_join(allTable_female_PE %>% dplyr::select(ensembl, hgnc_symbol, t, P.Value, adj.P.Val),
               allTable_male_PE %>% dplyr::select(ensembl, hgnc_symbol, t, P.Value, adj.P.Val),
               by=c('hgnc_symbol', 'ensembl'),
          suffix=c("_F", "_M"))

# write_csv(df2 %>% relocate(hgnc_symbol, .after=ensembl),
#           file=output_pValue_file)

```

# Identify transcription and splicing factors

```{r}
# add a new column indicating which genes are transcription factors
allTable_male_PE_TFs_SFs <-  allTable_male_PE %>%
  mutate(transcriptionFactor = ifelse(hgnc_symbol %in% gene_lists$Transcription_factors, "TF", NA))%>%
  mutate(splicingFactor = ifelse(hgnc_symbol %in% gene_lists$Splicing_factors, "SF", NA))
# identify which genes are both DE and TFs or SFs
DE_TFs_SFs <- dplyr::filter(allTable_male_PE_TFs_SFs, 
                       adj.P.Val < 0.05 & 
                       (transcriptionFactor == "TF" | splicingFactor == "SF"))
```


## Sanity plot of DE genes

```{r}
# let's take a look at the DE genes with the highest logFC that also have a "decent" expression level

# row center the counts
# do this by subtracting the row(gene) mean from each count

# center with 'scale()'
# setting `scale = FALSE` subtracts the mean rather than zero centering
center_scale <- function(x) {
    scale(x, scale = FALSE)
}

# apply it
row_centered_counts <- center_scale(t(dge_list_obj$counts)) %>% 
  t()

# which gene would we like to plot??
gene_to_plot <- "ENSG00000047457"

# png(filename=file.path(outdir, "expression_DE_gene_CP_sexOutcome.png'), width=800, height=800)
# Gene of Interest (GOI)
GOI_PE_UP <- data.frame(ensbl=c("ENSG00000178726", "ENSG00000115602",
                             "ENSG00000174697", "ENSG00000070404",
                             "ENSG00000169495", "ENSG00000136002",
                             "ENSG00000012223", "ENSG00000142623",
                             "ENSG00000224658", "ENSG00000102755",
                             "ENSG00000118849", "ENSG00000165810",
                             "ENSG00000211448", "ENSG00000243836",
                             "ENSG00000150722", "ENSG00000181458",
                             "ENSG00000159399"),
                  gene=c("THBD", "IL1RL1", "LEP", "FSTL3",
                         "HTRA4", "ARHGEF4", "LTF", "PADI1",
                         "RP11-631F7.1", "FLT1", "RARRES1",
                         "BTNL9", "DIO2", "WDR86-AS1", "PPP1R1C",
                         "TMEM45A", "HK2"),
                  direction = "up")

GOI_PE_male_UP <- topTable_male_pe %>%
  arrange(desc(logFC)) %>%
  dplyr::select(., ensbl = ensembl_gene_id, gene = hgnc_symbol)

GOI_PE_DOWN <- data.frame(ensbl=c("ENSG00000233913", "ENSG00000134548",
                                  "ENSG00000203859", "ENSG00000213088",
                                  "ENSG00000114473", "ENSG00000260719",
                                  "ENSG00000091137", "ENSG00000157064"),
                  gene=c("RPL10P9", "SPX", "HSD3B2", "ACKR1",
                         "IQCG", "AC009133.17", "SLC26A4", "NMNAT2"),
                  direction = "down")

GOI_UP_DOWN <- rbind(GOI_PE_UP, GOI_PE_DOWN)

samples <- dge_list_obj$samples

counts <- edgeR::cpm(dge_list_obj, log = TRUE)

pd <- position_dodge(width = 0.5)

lcpm <- edgeR::cpm(dge_list_obj, log = TRUE)

## Print all of the plots at once
for (i in 1:nrow(GOI_PE_UP)) {
melt_lcpm <- melt(subset(lcpm, rownames(lcpm) %in% GOI_PE_UP$ensbl[i])) %>% 
  as.data.frame() %>% 
  set_colnames(c("ensbl", "samplename", "log2cpm")) %>% 
  # tibble::rownames_to_column("samplename") %>% 
  left_join(., dge_list_obj$samples[, c("samplename", "Outcome", "Sex")], by = "samplename") 
  
beeswarm <- ggplot(melt_lcpm, aes(x = Sex,
                                y = log2cpm,
                                fill = Outcome)) +
  stat_boxplot(geom="errorbar",
               position = pd,
               width = 0.2) +
  geom_boxplot(width = 0.5,
               position = pd) +
  #     geom_boxplot(aes(x = Fetal.Sex,
  #                  y =  log2cpm,
  #                  fill = simpleOutcome)) +
  stat_summary(fun = mean,
               geom = "point",
               size=2,
               shape = 5,
               position = position_dodge(0.5)) +
  geom_beeswarm(dodge.width = 0.6, cex = 2) +
  theme_bw(base_size = 18) +
  ylab(paste("log2 CPM Counts", GOI_PE_UP$ensbl[i], GOI_PE_UP$gene[i], sep = " - ")) +
  theme(axis.text.x = element_text(colour = "black")) +
  theme(legend.position = "bottom")
print(beeswarm)
}

# graphics.off()
```

## Volcano plot for visualisation of differential expression
### male (for publication)

```{r}
# Create list of genes to label
genes_to_label <- c("CP", "CDH13", "IGFBP7", "COL6A3", "VCAN", 
                    "CSHL1", "ALPP", "NR3C2", "ELOVL6", "ITGA1", "ROBO1")

# Ensure consistent axis limits
max_fc <- max(abs(c(allTable_male_PE$logFC, allTable_female_PE$logFC)))
max_y <- max(-log10(c(allTable_male_PE$P.Value, allTable_female_PE$P.Value)))

# Function to create the "Differential Expression" factor
make_de_factor <- function(df) {
  factor(ifelse(df$adj.P.Val < 0.05,
                ifelse(df$logFC > 0, "Up", "Down"),
                "NS"),
         levels = c("Up", "Down", "NS"))
}

# Define a consistent scale for color
color_scale <- scale_color_manual(
  values = c("Up" = "green4", "Down" = "red3", "NS" = "grey"),
  labels = c("Up" = "Upregulated", "Down" = "Downregulated", "NS" = "Not Significant")
)

# Create the male plot
p1 <- ggplot(allTable_male_PE, aes(x = logFC, y = -log10(P.Value))) +
  geom_point(aes(color = make_de_factor(allTable_male_PE))) +
    geom_text_repel(
    data = subset(allTable_male_PE, hgnc_symbol %in% genes_to_label),
    aes(label = hgnc_symbol),
    max.overlaps = Inf,
    box.padding = 0.5,
    force = 2) +
  color_scale +
  scale_x_continuous(limits = c(-max_fc, max_fc), breaks = seq(-max_fc, max_fc, length.out = 9)) +
  scale_y_continuous(limits = c(0, max_y)) +
  labs(x = expression(log[2]~"Fold Change"),
       y = expression(-log[10]~"P-value"),
       title = "Male",
       color = "Differential Expression") +
  theme_bw()

# Create the female plot
p2 <- ggplot(allTable_female_PE, aes(x = logFC, y = -log10(P.Value))) +
  geom_point(aes(color = make_de_factor(allTable_female_PE))) +
  color_scale +
  scale_x_continuous(limits = c(-max_fc, max_fc), breaks = seq(-max_fc, max_fc, length.out = 9)) +
  scale_y_continuous(limits = c(0, max_y)) +
  labs(x = expression(log[2]~"Fold Change"),
       y = expression(-log[10]~"P-value"),
       title = "Female") +  # No color legend
  guides(color = "none") + # Suppress the legend
  theme_bw()

# Combine the plots and collect legends
combined_plot <- (p1 + p2) +
  plot_annotation(tag_levels = "a") +
  plot_layout(guides = "collect") &
  theme(legend.position = "bottom")

# Display the combined plot
print(combined_plot)


```


```{r volcano plots male}

decide <- decideTests(contrast_fit_sex_PE)
d2 <- topTable(contrast_fit_sex_PE, coef = 2, n = Inf, sort = "p") #[,c(2,6)]
d2$threshold <- 0
d2$threshold[0:nrow(filter(allTable_male_PE, adj.P.Val < 0.05))] <- 1
d2$threshold <- as.factor(d2$threshold)
d3 <- decideTests(contrast_fit_sex_PE) %>%
  as.data.frame()
d3 <- d3[2]
d4 <- left_join(tibble::rownames_to_column(d2), (tibble::rownames_to_column(d3)),
                       by = "rowname")
d4$male_PE <- as.factor(d4$male_PE)
d4$neg.log10FDR <- -log10(d4$adj.P.Val)
# set colours for the volcano plot
colour <- c("red", "black", "darkgreen")
FDR_FC_Decide <- decideTests(contrast_fit_sex_PE, lfc = 0)[,"male_PE"] %>%
  as.data.frame() %>%
  set_colnames("FDR_FC_Decide") %>%
  tibble::rownames_to_column() %>%
  left_join(., d4, by = "rowname")
FDR_FC_Decide$FDR_FC_Decide <- as.factor(FDR_FC_Decide$FDR_FC_Decide)

volcano_male <- ggplot(data = FDR_FC_Decide,
                  aes(x = logFC,
                      y = neg.log10FDR,
                      label = rowname,
                      colour = FDR_FC_Decide)) +
  geom_point(alpha=0.9, size=2.00) +
  xlab(expression(Log[2]*" Fold Change")) + ylab(expression("-ve "*Log[10]*" FDR")) +
  scale_color_manual(values = colour, name="mRNA\nRegulation",
                         breaks = c("-1", "0", "1"),
                         labels = c("Down-regulated", "Not Significant", "Up-regulated")) +
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_hline(yintercept = -log10(.05), linetype = "dotted") +
  geom_vline(xintercept = c(-1, 1), linetype = "dotted") +
  theme_bw() +
  theme(text = element_text(size=18)) +
  theme(axis.text.x = element_text(colour = "black",
                                   face = "bold"),
        axis.text.y = element_text(colour = "black",
                                   face = "bold")) +
  theme(axis.title.x = element_text(colour = "black",
                                   face = "bold"),
        axis.title.y = element_text(colour = "black",
                                   face = "bold")) +
  geom_label_repel(data = dplyr::filter(FDR_FC_Decide, FDR_FC_Decide==1),
                  aes(label = hgnc_symbol),
                  fill = "white",
                  xlim = c(7, 0),
                  max.overlaps = Inf,
                  show.legend = FALSE) +
  geom_label_repel(data = dplyr::filter(FDR_FC_Decide, FDR_FC_Decide==-1),
                  aes(label = hgnc_symbol),
                  fill = "white",
                  xlim = c(-7, 0),
                  max.overlaps = Inf,
                  show.legend = FALSE) +
  theme(legend.position="bottom")

ggsave(plot = volcano_male,
       filename = file.path(projectDir, "deduplicated_clearBox/output/volcano_male.png"),
       units = "in",
       width = 12,
       height = 12,
       dpi = 300)


```

### female

```{r volcano plots female}

decide <- decideTests(contrast_fit_sex_PE)
d2 <- topTable(contrast_fit_sex_PE, coef = 1, n = Inf, sort = "p") #[,c(2,6)]
d2$threshold <- 0
d2$threshold[0:nrow(filter(allTable_female_PE, adj.P.Val < 0.05))] <- 1
d2$threshold <- as.factor(d2$threshold)
d3 <- decideTests(contrast_fit_sex_PE) %>%
  as.data.frame()
d3 <- d3[1]
d4 <- left_join(tibble::rownames_to_column(d2), (tibble::rownames_to_column(d3)),
                       by = "rowname")
d4$female_PE <- as.factor(d4$female_PE)
d4$neg.log10FDR <- -log10(d4$adj.P.Val)
# set colours for the volcano plot
colour <- c("red", "black", "darkgreen")
FDR_FC_Decide <- decideTests(contrast_fit_sex_PE, lfc = 0)[,"female_PE"] %>%
  as.data.frame() %>%
  set_colnames("FDR_FC_Decide") %>%
  tibble::rownames_to_column() %>%
  left_join(., d4, by = "rowname")
FDR_FC_Decide$FDR_FC_Decide <- as.factor(FDR_FC_Decide$FDR_FC_Decide)

volcano_female <- ggplot(data = FDR_FC_Decide,
                  aes(x = logFC,
                      y = neg.log10FDR,
                      label = rowname,
                      colour = FDR_FC_Decide)) +
  geom_point(alpha=0.9, size=2.00) +
  xlab(expression(Log[2]*" Fold Change")) + ylab(expression("-ve "*Log[10]*" FDR")) +
  scale_color_manual(values = colour, name="mRNA\nRegulation",
                         breaks = c("-1", "0", "1"),
                         labels = c("Down-regulated", "Not Significant", "Up-regulated")) +
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_hline(yintercept = -log10(.05), linetype = "dotted") +
  geom_vline(xintercept = c(-1, 1), linetype = "dotted") +
  theme_bw() +
  theme(text = element_text(size=18)) +
  theme(axis.text.x = element_text(colour = "black",
                                   face = "bold"),
        axis.text.y = element_text(colour = "black",
                                   face = "bold")) +
  theme(axis.title.x = element_text(colour = "black",
                                   face = "bold"),
        axis.title.y = element_text(colour = "black",
                                   face = "bold")) +
  geom_label_repel(data = dplyr::filter(FDR_FC_Decide, FDR_FC_Decide==1),
                  aes(label = hgnc_symbol),
                  fill = "white",
                  xlim = c(7, 0),
                  max.overlaps = Inf,
                  show.legend = FALSE) +
  geom_label_repel(data = dplyr::filter(FDR_FC_Decide, FDR_FC_Decide==-1),
                  aes(label = hgnc_symbol),
                  fill = "white",
                  xlim = c(-7, 0),
                  max.overlaps = Inf,
                  show.legend = FALSE) +
  theme(legend.position="bottom")

ggsave(plot = volcano_female,
       filename = file.path(projectDir, "deduplicated_clearBox/output/volcano_female.png"),
       units = "in",
       width = 12,
       height = 12,
       dpi = 300)


```

# Pathway enrichment analysis

```{r}
# this pathway enrichment from (https://youtu.be/JPwdqdo_tRg?si=E9fEAQFJJoZE6MV1)
genes_to_test <- topTable_male_pe[topTable_male_pe$adj.P.Val < 0.05,] %>%
  dplyr::pull(., ensembl)

GO_results <- clusterProfiler::enrichGO(gene = genes_to_test,
                                        OrgDb = "org.Hs.eg.db",
                                        keyType = "ENSEMBL",
                                        ont = "BP")
as.data.frame(GO_results)

# this pathway enrichment from (https://youtu.be/4MZ2fEvTj0c)
# Functions--------------------------------------------
## Function: Adjacency matrix to list ##
matrix_to_list <- function(pws){
  pws.1 <- list()
  for (pw in colnames(pws)) {
    pws.1[[pw]] <- rownames(pws)[as.logical(pws[, pw])]
  }
  return(pws.1)
}

# Prepare data--------------------------------------------
# create the table required for this tutorial from the full topTable
df <- allTable_male_PE %>%
  dplyr::select(., gene_symbol = hgnc_symbol, pval = P.Value, padj = adj.P.Val, log2fc = logFC)

## Prepare background genes -------------------------------------
## gene sets (.gmt files) downloaded from GSEA MSigDB
# identify genes in the DE set to filter them from the gene sets of interest
genes_in_data <- df$gene_symbol

# create a list of gene set files (.gmt)
gmt_files <- list.files(path = paste0(projectDir, "/deduplicated_clearBox/rawData"),
                        pattern = '.gmt',
                        full.names = TRUE)
# import the .gmt files
for (file in gmt_files){
  pwl2 <- read.gmt(file) # all genes from db (C8: cell type signatures, H: Hallmark, C5 GO_BP, HP_MATERNAL_HYPERTENSION)
  pwl2 <- pwl2[pwl2$gene %in% genes_in_data, ] # background gene sets (pathways_ already filtered for those genes that)
  filename <- paste(gsub('c\\d+\\.', '', gsub('\\.v2024\\.1\\.Hs\\.symbols\\.gmt$', '', file)), '.RDS', sep = '') # tidy up the filenames
	saveRDS(pwl2, filename)
}

# annotate according to differential expression
df <- df %>%
  dplyr::mutate(., diffexpressed = case_when(
    log2fc > 0 & padj < 0.05 ~ 'UP',
    log2fc < 0 & padj < 0.05 ~ 'DOWN',
    padj >= 0.05 ~ 'NO'
  ))

# remove non-significant genes
df <- df[df$diffexpressed != 'NO', ]

# split the dataframe into a list of sub-dataframes: upregulated, downregulated genes
deg_results_list <- split(df, df$diffexpressed)

# Run ClusterProfiler--------------------------------------------
# Settings
bg_path <- file.path(projectDir, "deduplicated_clearBox/rawData/")
name_of_comparison <- 'preeclampsia'
background_genes <- 'go_bp'
bg_genes <- readRDS(paste0(bg_path, "/h.all.RDS"))
padj_cutoff <- 0.05
genecount_cutoff <- 5
filename <- paste0(outdir, '/clusterProfiler/', name_of_comparison, '_', background_genes)

# Read in background genes (alternative)
if(background_genes == 'hallmark_all'){
  bg_genes <- readRDS(paste0(bg_path, 'h.all.RDS'))
} else if(background_genes == 'cell_type'){
  bg_genes <- readRDS(paste0(bg_path, 'c8_all.RDS'))
} else if(background_genes == 'kegg'){
  bg_genes <- readRDS(paste0(bg_path, 'cp.kegg_legacy.RDS'))
} else if(background_genes == 'hypertension'){
  bg_genes <- readRDS(paste0(bg_path, 'MATERNAL_HYPERTENSION.RDS'))
} else if(background_genes == 'go_bp'){
  bg_genes <- readRDS(paste0(bg_path, 'go.bp.RDS'))
} else {
  stop('Invalid background genes. Select one of the following: hallmark_all, cell_type, go_bp, hypertension, kegg or add new pwl to function')
}

# Run clusterProfiler on each sub-dataframe
res <- lapply(names(deg_results_list),
                 function(x) enricher(gene = deg_results_list[[x]]$gene_symbol,
                                      TERM2GENE = bg_genes))
names(res) <- names(deg_results_list)
#Convert the list of enrichResults for each sample_pattern to a dataframe with the pathways
res_df <- lapply(names(res), function(x) rbind(res[[x]]@result))
names(res_df) <- names(res)
res_df <- do.call(rbind, res_df)
head(res_df)



```


## Heatmaps
```{r}
# Modify ordering of the clusters using clustering callback option
callback = function(hc, mat){
    sv = svd(t(mat))$v[,1]
    dend = reorder(as.dendrogram(hc), wts = sv)
    as.hclust(dend)
}

males <- dplyr::filter(dge_list_obj$samples, Sex == "M")

annotation_cols <- metadata[, c("samplename", "Sex", "Outcome")] %>%
  tibble::column_to_rownames("samplename") %>%
  dplyr::filter(., Sex == "M")

annotation_rows <- topTable_male_pe %>%
  dplyr::mutate(foldChange = dplyr::case_when(
    logFC > 0 ~ "up",
    logFC < 0 ~ "down"
  )) %>%
  dplyr::select(., foldChange)
# Define the color palette for row annotations
annotation_colors <- list(
  foldChange = c("down" = "red", "up" = "green")
)

scaled_exp <- scale(t(subset(edgeR::cpm(dge_list_obj, log = TRUE), rownames(edgeR::cpm(dge_list_obj, log = TRUE)) %in% dplyr::filter(FDR_FC_Decide, threshold == 1)$ensembl)))
scaled_male <- subset(scaled_exp, rownames(scaled_exp) %in% males$samplename)

# png(file=file.path(outdir, "heatmap_scaled_sig_AdjPVal_M.png"),
#     width=12,
#     height=8,
#     units = "in",
#     res = 150)
# pheatmap(t(scaled_male),
#          annotation_col = annotation_cols,
#          annotation_row = annotation_rows,
#          annotation_colors = annotation_colors,
#          show_rownames = FALSE,
#          show_colnames = TRUE,
#          cutree_cols = 3,
#          treeheight_row = FALSE,
#          clustering_callback = callback)
# dev.off()

```

## Prepare and save the rank file data for GSEA
### Female

```{r}

# Import female DE table
allTable_female <- read_csv(file.path(outdir, "allTable_female.csv"))


allTable_female["rank"] <- (sign(allTable_female$logFC))*(-log(allTable_female$adj.P.Val, 10))
rankFile_female <- dplyr::select(allTable_female, hgnc_symbol, rank) %>%
  arrange(., rank)

# write out the table ready for GSEAe
# write.table(rankFile_female,
#             file = file.path(outdir, "PE_female_rankFile.rnk"),
#             sep = "\t", 
#             row.names = FALSE,
#             col.names = TRUE,
#             quote = FALSE)

# write.table(rankFile_female,
#             file = file.path("/media/sf_D_DRIVE/VM_Projects/preeclampsia_sex_chromosome_informed/PE_female_rankFile.rnk"),
#             sep = "\t", 
#             row.names = FALSE,
#             col.names = TRUE,
#             quote = FALSE)


```

### Male

```{r}

# Import male DE table
allTable_male <- read_csv(file.path(outdir, "allTable_male.csv"))


allTable_male["rank"] <- (sign(allTable_male$logFC))*(-log(allTable_male$adj.P.Val, 10))
rankFile_male <- dplyr::select(allTable_male, hgnc_symbol, rank) %>%
  arrange(., rank)

# write out the table ready for GSEAe
# write.table(rankFile_male,
#             file = file.path(outdir, "PE_male_rankFile.rnk"),
#             sep = "\t", 
#             row.names = FALSE,
#             col.names = TRUE,
#             quote = FALSE)

# write.table(rankFile_male,
#             file = file.path("/media/sf_D_DRIVE/VM_Projects/preeclampsia_sex_chromosome_informed/PE_male_rankFile.rnk"),
#             sep = "\t", 
#             row.names = FALSE,
#             col.names = TRUE,
#             quote = FALSE)


```

## Plots for Melissa
- scatter plot of the male (x-axis) and female (y-axis) log2 fold change  

```{r}

# Import male DE table
allTable_male_PE <- read_csv(file.path(outdir, "allTable_male.csv"))

# Import female DE table
allTable_female_PE <- read_csv(file.path(outdir, "allTable_female.csv"))

df <- left_join(allTable_female_PE %>% dplyr::select(-t, -P.Value, -B),
               allTable_male_PE %>% dplyr::select(-t, -P.Value, -B),
               by=c('hgnc_symbol', 'ensembl'),
          suffix=c("_F", "_M"))


# Calculate the maximum absolute value across both logFC columns for symmetric axis scaling
max_abs_fc <- max(abs(c(df$logFC_M, df$logFC_F)), na.rm = TRUE)

# Create the scatter plot
p <- ggplot(df, aes(x = logFC_M, y = logFC_F)) +
  # Add all points in light grey
  geom_point(color = "lightgrey", size = 2, alpha = 0.7) +
  # Add significant points colored by direction of logFC_M
  geom_point(data = subset(df, adj.P.Val_M < 0.05), 
             aes(color = ifelse(logFC_M > 0, "green", "red")),
             size = 2.5) +
  # Add text labels ONLY for significant points that are in genes_to_label vector
  geom_text_repel(
    data = subset(df, adj.P.Val_M < 0.05 & hgnc_symbol %in% genes_to_label),
    aes(label = hgnc_symbol),
    max.overlaps = Inf,
    size = 3,
    box.padding = 0.5,
    point.padding = 0.2,
    segment.color = "grey50"
  ) +
  # Customize colors for significant points
  scale_color_identity() +
  # Set identical limits for both x and y axes and ensure ticks at every 0.5
  scale_x_continuous(limits = c(-max_abs_fc, max_abs_fc), 
                     breaks = seq(floor(-max_abs_fc), ceiling(max_abs_fc), 0.5),
                     minor_breaks = seq(floor(-max_abs_fc), ceiling(max_abs_fc), 0.1)) +
  scale_y_continuous(limits = c(-max_abs_fc, max_abs_fc), 
                     breaks = seq(floor(-max_abs_fc), ceiling(max_abs_fc), 0.5),
                     minor_breaks = seq(floor(-max_abs_fc), ceiling(max_abs_fc), 0.1)) +
  # Add reference lines at x=0 and y=0
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey50") +
  # Add labels and title
  labs(
    title = "Differential Gene Expression: Male vs Female",
    x = "Log2 Fold Change (Male)",
    y = "Log2 Fold Change (Female)"
  ) +
  # Use a clean theme
  theme_bw() +
  # Use a fixed aspect ratio to ensure visual equality
  coord_fixed(ratio = 1)

# Display the plot
print(p)

# ggsave(filename = file.path(outdir, "melissaPlots/logFC_M_v_logFC_M.jpeg"),
#        create.dir = TRUE,
#        plot = p,
#        units = "in",
#        width = 10,
#        height = 10,
#        dpi = 150)
```
- violin plots of selected DE genes  

```{r}
# make violin plots for the genes Melissa wants to see
# groups (x-axis) male_control, male_PE, female_control, female_PE
library(ggplot2)
library(dplyr)
library(tidyr)  # For pivot_longer()

# Step 1: Reshape log2CPM from wide to long format
log2CPM_long <- log2CPM %>%
  as.data.frame() %>%  
  rownames_to_column(var = "Gene") %>%   # Preserve gene names
  pivot_longer(cols = -Gene, names_to = "samplename", values_to = "Expression")

# Step 2: Merge with metadata to get 'sex_outcome' group
plot_data <- log2CPM_long %>%
  dplyr::left_join(metadata[, c("samplename", "sex_outcome")], by = "samplename") %>%  # Merge using sample names
  dplyr::left_join(., allTable_male_PE[, c("ensembl", "hgnc_symbol")], by = c("Gene" = "ensembl")) # Merge to include the gene symbol

# Step 3: Filter for the selected gene
selected_gene <- "ROBO1"  # Change this for other genes
gene_data <- plot_data %>%
  filter(hgnc_symbol == selected_gene)

# Step 4: Filter for samples in "M_PE" group for labeling
label_data <- gene_data %>%
  filter(sex_outcome == "M_PE")
         
# Step 5: Create Violin Plot for the selected gene
p <- ggplot(gene_data, aes(x = sex_outcome,
                           y = Expression,
                           fill = sex_outcome)) +
  geom_violin(trim = FALSE, alpha = 0.6) +  # Violin plot with transparency
  geom_jitter(width = 0.2, size = 0.8, alpha = 0.5) +  # Add jittered points
    geom_text_repel(data = label_data, aes(label = samplename), 
                  size = 3, nudge_x = 0.2, box.padding = 0.5) +  # Labels for M_PE
  theme_bw() +  # Clean theme
  scale_fill_manual(values = c("blue", "red", "blue", "red")) +
  labs(title = paste("Expression of", selected_gene, "by Sex & Outcome"),
       x = "Sex & Outcome",
       y = "Log2 CPM Expression") +
  theme(legend.position = "none")  # Hide legend if not needed

print(p)

# Step 5: Save the Violin Plot for the selected gene 
ggsave(filename = file.path(outdir, paste0("melissaPlots/", selected_gene, "_violin_withSamplename.jpeg")),
       create.dir = TRUE,
       plot = p,
       units = "in",
       width = 10,
       height = 10,
       dpi = 150)

```



# Session information
```{r session info}

sessionInfo()

```