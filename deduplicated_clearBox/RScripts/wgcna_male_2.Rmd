---
title: "wgcna"
author: "Melanie Smith"
date: "25 August 2024"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load Libraries
This script is based on the tutorial found here https://github.com/Lindseynicer/WGCNA_tutorial/blob/main/WGCNA_tutorial_Rscript
```{r}
library(WGCNA)
library(tidyverse)
library(GEOquery)
library(CorLevelPlot) #devtools::install_github("kevinblighe/CorLevelPlot")
library(gridExtra)
library(edgeR)
library(ggplot2)
library(pheatmap)
library(dplyr)

allowWGCNAThreads()

```

[Maternal-Fetal Interface](https://maternal-fetal-interface.cellgeni.sanger.ac.uk/)

# Set directories and paths

```{r}
# set project directory
projectDir <- "/home/smit1924/preeclampsia_sex_chromosome_informed"
# projectDir <- "/Users/pillmaka/Desktop/Melanie/drive-download"

# input files
counts <- file.path(projectDir, "deduplicated_clearBox/readCounts/deduplicated_s2_readCounts.txt")
metadata_file <- file.path(projectDir, "clearBoxRawData/cleanSampleMetadata.csv")
input_allTable_male <- file.path(projectDir, "deduplicated_clearBox/output/58_sample_noCovariate/allTable_male.csv")

## Cibersortx input files
input_deduplicated_cibersortx_adjusted_file <- file.path(projectDir, "deduplicated_clearBox/cibersortx_output/CIBERSORTx_Job10_Adjusted.txt")

## Blood pressure measurements
input_SCOPE_bloodPressure_file <- file.path(projectDir, "deduplicated_clearBox/rawData/SCOPE_bloodPressure.csv")
input_STOP_bloodPressure_file <- file.path(projectDir, "deduplicated_clearBox/rawData/STOP_bloodPressure.csv")

gene_info_file <- file.path(projectDir, "clearBoxCleanData/gencode_v29_gene_id_symbol_chr_biotype.csv")

# set the output directory
outdir <- file.path(projectDir, "deduplicated_clearBox/output/wgcna")

# set figure files
output_hclust_tree_file <- file.path(outdir, "hclust_tree.png")
output_pca_dim1_dim2_file <- file.path(outdir, "pca_dim1_dim2.png")
output_softpower_file <- file.path(outdir, "softPower.png")
output_blockwiseModuleDendrogram_file <- file.path(outdir, "blockwiseModuleDendrogram.png")
output_stepByStepDendrogram_file <- file.path(outdir, "stepByStepDendrogram.png")
output_stepByStepDendrogramModules_file <- file.path(outdir, "stepByStepDendrogramModules.png")
output_stepByStepDendrogramModulesMerged_file <- file.path(outdir, "stepByStepDendrogramModulesMerged.png")
output_oldMEs_file <- file.path(outdir, "oldMEs.txt")
output_newMEs_file <- file.path(outdir, "newMEs.txt")
output_eigengene_sample_heatmap_file <- file.path(outdir, "eigengene_sample_heatmap.png")
# output_eigengene_sample_cell_heatmap_file <- file.path(outdir, "eigengene_sample_cell_heatmap.png")
output_eigengene_sample_celltype_heatmap_file <- file.path(outdir, "eigengene_sample_celltype_heatmap.png")
output_module_trait_cor_heatmap_file <- file.path(outdir, "module_trait_cor_heatmap.png")
output_module_traitsAll_cor_heatmap_file <- file.path(outdir, "module_traitsAll_cor_heatmap.png")
output_correlation_heatmap_unmergedModules_file <- file.path(outdir, "module_to_module_cor_heatmap_unmergedModules.png")
output_correlation_heatmap_mergedModules_file <- file.path(outdir, "module_to_module_cor_heatmap_mergedModules.png")

```

# Import all input data tables
## sample metadata
```{r}

## Metadata
metadata <- read_csv(file = metadata_file)
# Filter metadata to exclude samples where Sex = "F"
filtered_metadata <- metadata %>%
  filter(Sex != "F")

```

## Gene info file
```{r}
## Gene ID versus GeneSymbol
gene_info <- read_csv(file = gene_info_file)
gene_info <- gene_info[!duplicated(gene_info$ensembl_gene_id), ]
```

## DE genes
```{r}
allTable_male <- read_csv(input_allTable_male) %>%
  dplyr::filter(., adj.P.Val <= 0.2)
```

# Cibersortx Results
## Heatmap of results
- S-mode batch correction  
- 100 x permutations  

```{r}
# import the cibersortx results
deduplicated_cibersortx_adjusted <- read.delim(file = input_deduplicated_cibersortx_adjusted_file) %>%
  tibble::column_to_rownames("Mixture") %>%
  # drop all but the male samples we want
  tibble::rownames_to_column("samplename") %>%
  # Remove "_dedup" suffix from the samplename column
  dplyr::mutate(samplename = str_remove(samplename, "_dedup"))
  
```

# Blood Pressure information
```{r}
# SCOPE blood pressure data. BPs taken at the *15* week visit
# NB: we use the second measure
SCOPE_bloodPressure <- read_csv(input_SCOPE_bloodPressure_file) %>%
  subset(., samplename %in% filtered_metadata$samplename)
# STOP blood pressure data. BPs taken at the *12* week visit
STOP_bloodPressure <- read_csv(input_STOP_bloodPressure_file) %>%
  subset(., samplename %in% filtered_metadata$samplename) %>%
  dplyr::mutate(., map =  f9_dbp + ((1/3)*(f9_sbp - f9_dbp)))

# Combine the SCOPE and STOP blood pressure measurements
combined_bloodPressure <- rbind(dplyr::select(SCOPE_bloodPressure, samplename, map = f11c_1st_vst_map_2nd),
                                dplyr::select(STOP_bloodPressure, samplename, map))

```


## Raw Counts
```{r}
# import the counts table
# counts are annotated to GRCh38
rawCounts_deduplicated <- read.delim(file = counts)
# tidy up the column names
colnames(rawCounts_deduplicated) <- gsub("X.media.sf_D_DRIVE.VM_Projects.20240619_deduplicateBams.deduplicated_data.|_marked_duplicates.bam|_T.*|_",
                                 "",
                                 colnames(rawCounts_deduplicated))

# # clean up the rownames - the are still in the 'ensembl + version' nomenclature
# counts <- dplyr::left_join(rawCounts_deduplicated %>% tibble::rownames_to_column("ensembl_gene_id"), gene_info %>% dplyr::select(., ensembl_gene_id, ensembl), by = "ensembl_gene_id") %>%
#   # subset the raw counts to only include the top 80% of DE genes
#   dplyr::filter(ensembl %in% allTable_male$ensembl) %>%
#   dplyr::select(., -ensembl_gene_id) %>%
#   tibble::column_to_rownames("ensembl") %>%
#   # drop female columns
#   dplyr::select(., filtered_metadata$samplename)
```

# Establish DGElist object

```{r}
# drop the samples not required for this analysis
counts <- rawCounts_deduplicated %>%
  tibble::column_to_rownames("Geneid")
# ensure the counts and metadata are in the same order
counts <- counts[, metadata$samplename]

# drop rows with zero in all columns
counts <- counts[rowSums(counts[])>0,] %>%
  tibble::rownames_to_column("ensembl_gene_id")

# add the hgnc gene symbol, chromosome and biotype to the counts matrix
counts_hgnc <- dplyr::left_join(counts, gene_info, by = "ensembl_gene_id") %>%
  dplyr::select(., ensembl_gene_id, ensembl, hgnc_symbol, seqnames, gene_type, everything())
dim(counts_hgnc) # 43423 63

# drop rows with NAs introduced in the join
counts_hgnc_clean <- counts_hgnc %>%
  filter(!is.na(ensembl))
dim(counts_hgnc_clean) # 42645 63

# establish the DGEList
dge_list_obj <- edgeR::DGEList(counts = counts_hgnc_clean %>%
                          tibble::column_to_rownames("ensembl") %>%
                          dplyr::select(., -hgnc_symbol, -ensembl_gene_id, -seqnames, -gene_type),
                        samples = metadata,
                        group = metadata$group,
                        genes = counts_hgnc_clean %>% dplyr::select(ensembl, hgnc_symbol, seqnames, gene_type))

```

# Filter biological noise
- I am keeping the filtering and normalisation steps here, even though I am using the DE genes to subset the final expression table, because I need to the expression values to be the same as the expression values that went into the DE in the first place.  

```{r}

# new df of unfiltered cpm for the reduced DGEList
preFilterCPM <- edgeR::cpm(dge_list_obj)

# remove low expressed genes (filterCPM in numSamples PE)
keep.exprs <- rowSums(preFilterCPM > 2) >= 5

# Perform the filtering step and recalculate the TMM normalisation factors for each library.
dge_list_obj <- dge_list_obj[keep.exprs,,keep.lib.sizes = FALSE]

dim(dge_list_obj)

```

# TMM normalisation

```{r}
# calculate normalisation factors and apply to the DGEList object
dge_list_obj <- edgeR::calcNormFactors(dge_list_obj,
                                method = "TMM")

# # set the new factor levels
sex_outcome_levels <- c("F_Control", "M_Control", "F_PE", "M_PE")
dge_list_obj$samples$sex_outcome <- factor(dge_list_obj$samples$sex_outcome, levels=sex_outcome_levels)

# saveRDS(dge_list_obj,
#         file = file.path(projectDir, "deduplicated_clearBox/output/filt_norm_dgelist_58_post_dedup.rds"))

```

# Keep only male samples

```{r}
male_dgeList <- dge_list_obj[dge_list_obj$genes$ensembl %in% allTable_male$ensembl, dge_list_obj$samples$samplename %in% filtered_metadata$samplename]

# replace the ensembl ID in the rownames with the hgnc gene symbol
# Ensure the 'hgnc_symbol' column exists in 'male_dgeList$genes'
if ("hgnc_symbol" %in% colnames(male_dgeList$genes)) {
  # Replace rownames in the 'counts' and 'genes' elements with 'hgnc_symbol'
  rownames(male_dgeList$counts) <- male_dgeList$genes$hgnc_symbol
  rownames(male_dgeList$genes) <- male_dgeList$genes$hgnc_symbol
} else {
  warning("The 'hgnc_symbol' column does not exist in male_dgeList$genes.")
}

```

## Genes and Samples driving variability
- create a distance matrix to determine which samples are more closely related.  
- Samples that are clustered together in the heatmap are more similar to each other in terms of their gene expression profiles.  
- Sample gene expression does not cluster on outcome or gestational age.  
- STP0148 and SCP4157 appear to be more similar to each other than to any other samples.  

```{r figure 1 - sample distances, fig.width = 7, fig.height = 5}

lcpm <- edgeR::cpm(male_dgeList, log = TRUE)
sampleDists <- dist(t(lcpm))
sampleDistMatrix <- as.matrix(sampleDists)

annotation_row <- data.frame(gestationalAge = as.integer(male_dgeList$samples$GestationalAge),
                             outcome = male_dgeList$samples$Outcome)

rownames(annotation_row) <- male_dgeList$samples$samplename

pheatmap::pheatmap(sampleDistMatrix,
         annotation_col = annotation_row,
         cutree_rows = 4,
         cutree_cols = 4,
         show_rownames = TRUE,
         main = "Sample v Sample correlation")

```

## Create a sample-sample network
One of the first things we can do is to see if we have samples that cluster and whether these clusters associate with our traits of interest.  

```{r sample sample network}

# Create an adjacency matrix of log2 transformed counts (squared Euclidean distance)
# counts need to be samples in columns and genes in rows for this
adjacency <- WGCNA::adjacency(edgeR::cpm(male_dgeList,
                                         log = TRUE),
                              type = "distance")

#calculate the whole network connectivity
k <- as.numeric(apply(adjacency,2,sum))-1
# standardise connectivity
Z.k <- scale(k)

# Designate samples as outlying if their Z.k value is below threshold
thresholdZ.k <- -2.5 # often -2.5 - indicates standard deviations away from other samples when is outlier

# colour the vector indicating outliers
outlierColour <- ifelse(Z.k < thresholdZ.k, "red", "black")

# calculate the cluster tree using flashClust
## dis-similarity matrix calculated as 1-adjacency matrix
sampleTree <- flashClust::flashClust(as.dist(1-adjacency),
                     method = "average")

# convert traits to colour representation
# where red indicates high values
# create an object of the sample metadata
samples <- male_dgeList$samples %>%
  # remove unwanted columns
  dplyr::select(., -norm.factors,
                -deliveryMode,
                -reportedOutcome,
                -group.1,
                -group,
                -Outcome,
                -Sex
                ) %>%
  dplyr::left_join(., combined_bloodPressure, by = "samplename") %>%
  dplyr::select(., -samplename)

# convert characters to factors and set factor levels
samples$cohort <- factor(samples$cohort, c("SCOPE", "STOP"))
samples$SmokingStatus <- factor(samples$SmokingStatus, c("N", "Y"))
samples$Ethnicity <- factor(samples$Ethnicity, c("Caucasian",
                                                 "Aboriginal",
                                                 "SouthEastAndFarEast",
                                                 "Asian",
                                                 "Polynesian"))
samples <- samples %>%
  # convert factors to numeric for colour assignment
  mutate_if(is.factor, as.numeric)

# convert numbers to colours
traitColours <- data.frame(numbers2colors(samples, signed = FALSE))
dimnames(traitColours)[[2]] <- paste(names(samples), "C", sep = "")
datColours <- data.frame(outlierC = outlierColour, traitColours)

# Plot the sample dendrogram and the colours underneath
WGCNA::plotDendroAndColors(sampleTree,
                    groupLabels = names(datColours),
                    colors = datColours,
                    main = "Sample Dendrogram and Heatmap")
```

## Network Construction

Prior to identifying which genes are correlated with each other, need to select a soft power threshold

The first step in constructing a scale-free gene co-expression requires choosing a soft-thresholding power. 

Here, we test a range of possible soft-thresholding powers to find the minimum one which results in approximately [scale-free topology](https://en.wikipedia.org/wiki/Scale-free_network) for the male and female gene expression networks. We define an appropriate minimum scale-free topology fitting index *R<sup>2</sup>* to be at least 0.20 (80% confidence). This step takes a couple of mins to run. 

```{r Choose-Soft-Thresholding-Power, message=FALSE, warning=FALSE}

# 1. Normalize the counts to CPM (log-transformed)
lcpm <- edgeR::cpm(male_dgeList, log = TRUE)

# 2. Transpose the data for WGCNA (genes should be in columns, samples in rows)
datExpr <- t(lcpm)

# 3. Check for good genes and samples (optional but recommended)
gsg <- goodSamplesGenes(datExpr, verbose = 3)
if (!gsg$allOK) {
  datExpr <- datExpr[gsg$goodSamples, gsg$goodGenes]
}

# 4. Run the pickSoftThreshold function to choose an appropriate power
powers <- c(seq(1, 10,by = 1),
            seq(12, 30, by = 2))  # Define a range of soft-thresholding powers
sft <- pickSoftThreshold(data = datExpr,
                         networkType = "signed",
                         powerVector = powers,
                         verbose = 5)

# 5. Inspect the results
print(sft$powerEstimate)

# Plot the results (optional)
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab = "Soft Threshold (power)", ylab = "Scale Free Topology Model Fit, signed R^2",
     type = "n", main = "Scale independence")
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels = powers, cex = 0.9, col = "red")
abline(h = 0.90, col = "red")  # Threshold for selecting a suitable power

plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab = "Soft Threshold (power)", ylab = "Mean Connectivity",
     type = "n", main = "Mean Connectivity")
text(sft$fitIndices[,1], sft$fitIndices[,5],
     labels = powers, cex = 0.9, col = "red")
abline(h = 0.90, col = "red")  # Threshold for selecting a suitable power

```

The `pickSoftThreshold` function suggests the most appropriate soft-thresholding power to be used in network construction. `r sft$powerEstimate` is the soft-thresholding power suggested.

Next the adjacency matrix will be created for the formation of the gene co-expression network

:   The **adjacency matrix** is a matrix that where the genes are both the columns and rows and the matrix is filled with the correlation value between each pair of genes.

In developing a network, the direction of the correlation of genes is important. The stringency applied when identifying biologically significant modules will increase by only identifying those genes which are positively correlated with one another.

# Create Topological Overlap Matrix
```{r}
# # make sure we pull cor() from the WGCNA name space
# cor <- WGCNA::cor
# 
# # set the soft power identified earlier
# power <- sft$powerEstimate
# 
# ## Option 1: use the blockwise "automatic" module creation. This can be faster when running large datasets but does limit some of our choices. I'll run it and take a look but will likely go ahead with the step-by-step module creation for this smaller dataset.
# net <- blockwiseModules(datExpr,
#                         TOMType = "signed",
#                         power = power,
#                         minModuleSize = 30,
#                         reassignThreshold = 0,
#                         mergeCutHeight = 0.25,
#                         numericLabels = TRUE,
#                         pamRespectsDendro = FALSE,
#                         saveTOMs = FALSE,
#                         verbose = 3)

# # return the cor() function to default
# cor <- stats::cor
# 
# # Plot the blockwise modules
# sizeGrWindow(12, 9)
# mergedColors <- labels2colors(net$colors)
# # png(file = output_blockwiseModuleDendrogram_file,
# #     width = 12,
# #     height = 6,
# #     units = "in",
# #     res = 150)
# plotDendroAndColors(net$dendrograms[[1]], mergedColors[net$blockGenes[[1]]],
#                     "Module Colours",
#                     dendroLabels = FALSE,
#                     hang = 0.03,
#                     addGuide = TRUE,
#                     guideHang = 0.05)
# # dev.off()

## Option 2: step-by-step

# set the soft power identified earlier
softPower <- sft$powerEstimate

# create the adjacency matrix: Adjacency Matrix: Represents how strongly genes are connected to each other based on their expression.
# The adjacency matrix represents the pairwise connection strength between genes based on their expression levels. The adjacency function applies the power transformation to the correlation matrix of the expression data, raising the correlations to the specified power to emphasize stronger correlations and reduce weaker correlations. This is essential for network construction in WGCNA.
# The resulting adjacency matrix has values between 0 and 1, representing the strength of connections between genes.
adjacency <- adjacency(datExpr,
                       type = "signed",
                       power = softPower)

# Calculate the Topological Overlap Matrix (TOM): TOM: Refines these connections by considering shared neighbors (i.e., indirect connections between genes).
# The TOM measures the interconnectedness of genes by considering not only the direct correlation between two genes but also the genes they are connected to. Genes with a high TOM value are part of a tightly connected network or module.
# The TOM matrix refines the adjacency matrix by identifying modules of genes that are highly interconnected.
# The TOM matrix, like the adjacency matrix, contains values between 0 and 1. Higher values in the TOM matrix indicate stronger connections between genes in terms of their shared neighbors in the network.
TOM <- TOMsimilarity(adjacency,
                     TOMType = "signed")

# Calculate the dissimilarity matrix (or distance matrix) based on the TOM. Dissimilarity Matrix (dissTOM): Converts the TOM into a distance measure, which is used for clustering genes into co-expression modules
dissTOM <- 1-TOM
dim(dissTOM)

# Construct modules: cluster genes into co-expression modules
geneTree <- hclust(as.dist(dissTOM),
                   method = "average")

# plot the step-by-step modules
# png(file = output_stepByStepDendrogram_file,
#     width = 12,
#     height = 6,
#     units = "in",
#     res = 150)
plot(geneTree,
     xlab="",
     sub="",
     main="Gene Clustering on TOM-based dissimilarity matrix",
     labels = FALSE,
     hang = 0.04)
# dev.off()

# Module identification using dynamic tree cut
dynamicModules <- cutreeDynamic(dendro = geneTree,
                                distM = dissTOM,
                                deepSplit = 4,
                                pamRespectsDendro = FALSE,
                                minClusterSize = 30)
table(dynamicModules)
# how many modules do we have?
length(table(dynamicModules)) # 19 modules including the grey module

# convert numeric labels into colours
dynamicColours <- labels2colors(dynamicModules)
# table giving the number of genes in each un-merged cluster
unmergedClusters <- data.frame(table(dynamicColours))

# plot dendrogram with colour modules
# png(file = output_stepByStepDendrogramModules_file,
#     width = 12,
#     height = 6,
#     units = "in",
#     res = 150)
plotDendroAndColors(geneTree,
     dynamicColours,
     "Dynamic Tree Cut",
     dendroLabels = FALSE,
     hang = 0.03,
     addGuide = TRUE,
     guideHang = 0.05,
     main = "Gene Dendrogram")
# dev.off()

# Create a data frame showing which un-merged module each gene is assigned to
unmerged_gene_module_table <- data.frame(
  Gene = colnames(datExpr),
  Module = dynamicColours
)


# Merge Modules
## Calculate Eigengenes
MEList <- moduleEigengenes(datExpr,
                           colors = dynamicColours)
MEs <- MEList$eigengenes
# Calculate dissimilarity of eigengenes
MEDiss <- 1-cor(MEs)
# Cluster module eigengenes
METree <- hclust(as.dist(MEDiss),
                 method = "average")
# Plot the result - clusters of similarity based on eigengene
plot(METree,
     main = "Clustering of Module Eigengenes",
     xlab = "",
     sub = "")

# We have 19 modules which means some have very few genes. We might like to merge some of the modules to help with downstream GSEA
# Merge similar modules based on a 15% simnilarity
MEDissThreshold <- 0.15
abline(h = MEDissThreshold, col = "red")
merge <- mergeCloseModules(datExpr,
                           dynamicColours,
                           cutHeight = MEDissThreshold,
                           verbose = 3)

mergedColours <- merge$colors
# how many modules do we have?
length(table(mergedColours))

# Create a data frame showing which merged module each gene is assigned to
merged_gene_module_table <- data.frame(
  Gene = colnames(datExpr),
  Module = merge$colors
)

merged_module_summary <- merged_gene_module_table %>%
  group_by(Module) %>%
  summarise(GeneCount = n()) %>%
  arrange(desc(GeneCount))

# sample by sample of eigengene expression values for the merged clusters
mergedMEs <- merge$newMEs 

# Plot merged module tree
# png(file = output_stepByStepDendrogramModulesMerged_file,
#     width = 12,
#     height = 6,
#     units = "in",
#     res = 150)
plotDendroAndColors(geneTree, cbind(dynamicColours, mergedColours), 
                    c("Dynamic Tree Cut", "Merged Dynamic"),
                    dendroLabels = FALSE, 
                    hang = 0.03,
                    addGuide = TRUE,
                    guideHang = 0.05)  
# dev.off()
# write.table(merge$oldMEs,file=output_oldMEs_file)
# write.table(merge$newMEs,file=output_newMEs_file)

```

# Export network data for cytoscape

```{r}
# Export the gene list of old modules 
# for (i in 1:length(merge$oldMEs)){
#   modules = c(substring(names(merge$oldMEs)[i], 3));
#   genes = colnames(datExpr)
#   inModule = is.finite(match(dynamicColours,modules))
#   modGenes = genes[inModule]
#   modTOM=TOM[inModule,inModule]
#   dimnames(modTOM)=list(modGenes,modGenes)
#   cyt = exportNetworkToCytoscape(modTOM,
#                                  edgeFile = paste(outdir, "/orign_CytoscapeInput-edges-", paste(modules, collapse="-"), ".txt", sep=""),
#                                  nodeFile = paste(outdir, "/orign_CytoscapeInput-nodes-", paste(modules, collapse="-"), ".txt", sep=""),
#                                  weighted = TRUE, threshold = -1, nodeNames = modGenes, nodeAttr = dynamicColours[inModule]);
# }
# 
# Export the gene list of new modules
for (i in 1:length(merge$newMEs)){
  modules = c(substring(names(merge$newMEs)[i], 3));
  genes = colnames(datExpr)
  # inModule = is.finite(match(dynamicColours,modules))
  inModule = is.finite(match(merge$colors,modules))
  modGenes = genes[inModule]
  modTOM=TOM[inModule,inModule]
  dimnames(modTOM)=list(modGenes,modGenes)
  cyt = exportNetworkToCytoscape(modTOM,
                                 edgeFile = paste(outdir, "/merge_CytoscapeInput-edges-", paste(modules, collapse="-"), ".txt", sep=""),
                                 nodeFile = paste(outdir, "/merge_CytoscapeInput-nodes-", paste(modules, collapse="-"), ".txt", sep=""),
                                 weighted = TRUE,
                                 threshold = -1,
                                 nodeNames = modGenes,
                                 nodeAttr = merge$colors[inModule]);
}


# Get list of all edge and node files
edge_files <- list.files(path = outdir, 
                        pattern = "merge_CytoscapeInput-edges", 
                        full.names = TRUE)

node_files <- list.files(path = outdir, 
                        pattern = "merge_CytoscapeInput-nodes", 
                        full.names = TRUE)

# Read and combine edge files
all_edges <- edge_files %>%
  map_df(~read.table(., header = TRUE, sep = "\t", stringsAsFactors = FALSE)) %>%
  dplyr::select(Source = fromNode,
                Target = toNode,
                Weight = weight)

# Save edge file
write.csv(all_edges, 
          file = paste0(outdir, "/combined_edges.csv"), 
          row.names = FALSE)

# Read and combine node files
all_nodes <- node_files %>%
  map_df(~read.table(., header = TRUE, sep = "\t", stringsAsFactors = FALSE)) %>%
  dplyr::select(., Id = nodeName,
                Label = nodeName,
                Modularity_Class = nodeAttr.nodesPresent...)

# Check for duplicate pairs
duplicates <- all_edges %>%
  group_by(Source, Target) %>%
  filter(n() > 1)

# Save node file
write.csv(all_nodes, 
          file = paste0(outdir, "/combined_nodes.csv"), 
          row.names = FALSE)

# Optional: check dimensions of combined objects
dim(all_edges)
dim(all_nodes)


```

# Correlate module to module eigengenes
## Un-merged modules
```{r}
ME_cor <- cor(MEList$eigengenes)

# png(file = output_correlation_heatmap_unmergedModules_file,
#     width = 12,
#     height = 6,
#     units = "in",
#     res = 150)
pheatmap(ME_cor,
         cluster_col = TRUE,
         cluster_row = TRUE,
         cutree_rows = 4,
         show_rownames = TRUE,
         show_colnames = TRUE,
         fontsize = 12,
         main = "Module Eigengene Correlation (un-merged)")
# dev.off()

```

## Merged modules
```{r}
ME_merged_cor <- cor(mergedMEs)

# png(file = output_correlation_heatmap_mergedModules_file,
#     width = 12,
#     height = 6,
#     units = "in",
#     res = 150)
pheatmap(ME_merged_cor,
         cluster_col = TRUE,
         cluster_row = TRUE,
         cutree_rows = 4,
         show_rownames = TRUE,
         show_colnames = TRUE,
         fontsize = 12,
         main = "Module Eigengene Correlation (merged)")
# dev.off()

```


# Correlate module eigen-genes and samples (or other discrete data)

```{r}

# Heatmap of module eigen-genes and sample traits of interest
# first set up some information for the annotation
col_ann <- filtered_metadata[,c("samplename", "GestationalAge", "BMI", "maternalAge", "sex_outcome")] %>%
  tibble::column_to_rownames("samplename")
col_ann <- data.frame(col_ann)
col_ann$sex_outcome <- as.factor(col_ann$sex_outcome)
head(col_ann)

# pull the module eigengene "expression" value from the merged modules
eigenGene_expr <- data.frame(merge$newMEs)
eigenGene_expr <- eigenGene_expr[order(match(rownames(eigenGene_expr), rownames(col_ann))),]
dim(merge$newMEs)

# png(file = output_eigengene_sample_heatmap_file,
#     width = 12,
#     height = 6,
#     units = "in",
#     res = 150)
pheatmap(eigenGene_expr,
         cluster_col=TRUE,
         cluster_row=TRUE,
         cutree_rows = 4,
         show_rownames=TRUE,
         show_colnames=TRUE,
         fontsize=6,
         annotation_row = col_ann)
# dev.off()

# Create col_ann_cell_type with selected cell types
col_ann_cell_type <- deduplicated_cibersortx_adjusted[, c("samplename", 
                                                          "Fetal.Mesenchymal.Stem.Cells",
                                                          "CD14..Monocytes",
                                                          "Naive.CD8..T.Cells",
                                                          "B.Cells", 
                                                          "Fetal.GZMK..Natural.Killer",
                                                          "Fetal.Hofbauer.Cells",
                                                          "Fetal.GZMB..Natural.Killer",
                                                          "Fetal.Endothelial.Cells", 
                                                          "Fetal.Syncytiotrophoblast",
                                                          "Fetal.Fibroblasts",
                                                          "Cytotrophoblast", 
                                                          "Fetal.Nucleated.Red.Blood.Cells",
                                                          "Fetal.Extravillous.Trophoblasts")] %>%
  tibble::column_to_rownames("samplename") %>%
  as.data.frame()

# Subset col_ann_cell_type to only include rownames present in filtered_metadata
col_ann_cell_type <- col_ann_cell_type[rownames(col_ann_cell_type) %in% filtered_metadata$samplename, ]

# Ensure the rows of col_ann_cell_type match the order of eigenGene_expr
col_ann_cell_type <- col_ann_cell_type[match(rownames(eigenGene_expr), rownames(col_ann_cell_type)), ]

# Define colors for each cell type 
annotation_colors <- list(
  "Fetal.Mesenchymal.Stem.Cells" = colorRampPalette(RColorBrewer::brewer.pal(9, "Blues"))(25),
  "CD14..Monocytes" = colorRampPalette(RColorBrewer::brewer.pal(9, "Reds"))(25),
  "Naive.CD8..T.Cells" = colorRampPalette(RColorBrewer::brewer.pal(9, "Greens"))(25),
  "B.Cells" = colorRampPalette(RColorBrewer::brewer.pal(9, "Purples"))(25),
  "Fetal.GZMK..Natural.Killer" = colorRampPalette(RColorBrewer::brewer.pal(9, "Oranges"))(25),
  "Fetal.Hofbauer.Cells" = colorRampPalette(RColorBrewer::brewer.pal(9, "BuGn"))(25),
  "Fetal.GZMB..Natural.Killer" = colorRampPalette(RColorBrewer::brewer.pal(9, "BuPu"))(25),
  "Fetal.Endothelial.Cells" = colorRampPalette(RColorBrewer::brewer.pal(9, "GnBu"))(25),
  "Fetal.Syncytiotrophoblast" = colorRampPalette(RColorBrewer::brewer.pal(9, "Greys"))(100),
  "Fetal.Fibroblasts" = colorRampPalette(RColorBrewer::brewer.pal(9, "OrRd"))(25),
  "Cytotrophoblast" = colorRampPalette(RColorBrewer::brewer.pal(9, "PuBuGn"))(100),
  "Fetal.Nucleated.Red.Blood.Cells" = colorRampPalette(RColorBrewer::brewer.pal(9, "RdPu"))(25),
  "Fetal.Extravillous.Trophoblasts" = colorRampPalette(RColorBrewer::brewer.pal(9, "YlGnBu"))(25)
  # Add additional color mappings for other columns
)

# Generate heatmap
# png(file = output_eigengene_sample_celltype_heatmap_file,
#     width = 12,
#     height = 6,
#     units = "in",
#     res = 150)
pheatmap(eigenGene_expr,
         cluster_col = TRUE,
         cluster_row = TRUE,
         cutree_rows = 4,
         show_rownames = TRUE,
         show_colnames = TRUE,
         fontsize = 6,
         annotation_row = col_ann_cell_type,
         annotation_colors = annotation_colors)  # Add the custom color palette
# dev.off()
```



# Correlate modules with traits
```{r}
# Function to create module-trait correlation heatmap
create_module_trait_correlation <- function(module_type = "unmerged",
                                            MEs, 
                                            mergedMEs,
                                            trait_data,
                                            p_threshold = 0.05,
                                            main_title = NULL) {
  # Select appropriate module data based on type
  modules_of_interest <- switch(module_type,
                                "unmerged" = MEs,
                                "merged" = mergedMEs,
                                stop("module_type must be either 'unmerged' or 'merged'"))
  
  # Verify sample name alignment
  if (!all(rownames(modules_of_interest) == rownames(trait_data))) {
    stop("Sample names in modules and trait data do not match")
  }
  
  # Calculate correlations and p-values
  nSamples <- nrow(modules_of_interest)
  moduleTraitCor <- cor(modules_of_interest, trait_data, use = "p")
  moduleTraitPvalue <- corPvalueStudent(moduleTraitCor, nSamples)
  
  # Create text matrix for significant correlations
  textMatrix <- ifelse(moduleTraitPvalue < p_threshold,
                       paste(signif(moduleTraitCor, 2), "\n(",
                             signif(moduleTraitPvalue, 1), ")",
                             sep = ""),
                       "")
  
  # Set default title if none provided
  if (is.null(main_title)) {
    main_title <- paste("Module-Trait Relationships (", module_type, ")", sep = "")
  }
  
  # Create heatmap
  par(mar = c(15, 12, 5, 5))
  labeledHeatmap(Matrix = moduleTraitCor,
                 xLabels = colnames(trait_data),
                 yLabels = colnames(modules_of_interest),
                 ySymbols = colnames(modules_of_interest),
                 colorLabels = FALSE,
                 colors = blueWhiteRed(50),
                 textMatrix = textMatrix,
                 setStdMargins = FALSE,
                 cex.text = 0.5,
                 main = main_title)
  
  # Return correlation and p-value matrices for potential further use
  return(list(
    correlation = moduleTraitCor,
    pvalues = moduleTraitPvalue,
    significant_correlations = textMatrix
  ))
}

# Example usage for cell type correlations:
cell_type_cors <- create_module_trait_correlation(
  module_type = "merged",  # or "unmerged"
  MEs = MEs,
  mergedMEs = mergedMEs,
  trait_data = col_ann_cell_type
)


# Example usage for all traits:

# Save the heatmap as a PNG file
# png(file = output_module_trait_cor_heatmap_file,
#     width = 12,
#     height = 10,
#     units = "in",
#     res = 150)

all_trait_cors <- create_module_trait_correlation(
  module_type = "merged",  # or "unmerged"
  MEs = MEs,
  mergedMEs = mergedMEs,
  trait_data = traitsAll,
  main_title = "Module-Trait Relationships Including Metadata"
)

# dev.off()
```

# Intramodular connectivity: identifying genes with high geneModuleMembership & geneTraitSignficance
## Un-Merged

```{r}
# set the trait/cell-type of interest
name_traitOfInterest <- "Cytotrophoblast"
# set the module of interest
# module <- "yellow"

traitOfInterest <- traitsAll %>%
  pull(!!sym(name_traitOfInterest)) %>%
  as.data.frame()
# Rename the column for clarity
names(traitOfInterest) <- name_traitOfInterest

# Extract module names from the Module Eigengenes (MEs) object
modNames <- substring(names(MEs), 3)

# Combine Module Eigengenes (MEs) with traitOfInterest data
# orderMEs function orders the combined data for better visualization
MET <- orderMEs(cbind(MEs, traitOfInterest))

# Calculate Gene Module Membership (correlation between gene expression and module eigengenes)
geneModuleMembership <- as.data.frame(cor(datExpr, MEs, use = "p"))
# Calculate p-values for the Gene Module Membership correlations
MMPvalue <- as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples))

# Rename columns in geneModuleMembership and MMPvalue for clarity (MM = Module Membership, p.MM = p-value Module Membership)
names(geneModuleMembership) <- paste("MM", modNames, sep="")
names(MMPvalue) <- paste("p.MM", modNames, sep="")

# Calculate Gene Trait Significance (correlation between gene expression and traitOfInterest trait)
geneTraitSignificance = as.data.frame(cor(datExpr, traitOfInterest, use = "p"))
# Calculate p-values for the Gene Trait Significance correlations
GSPvalue <- as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))

# Rename columns in geneTraitSignificance and GSPvalue for clarity (GS = Gene Significance, p.GS = p-value Gene Significance)
names(geneTraitSignificance) <- paste("GS.", names(traitOfInterest), sep="")
names(GSPvalue) <- paste("p.GS.", names(traitOfInterest), sep="")

# # Plot the dendrogram
# sizeGrWindow(6,6)
# par(cex = 1.0)
# plotEigengeneNetworks(MET,
#                       "Eigengene dendrogram",
#                       marDendro = c(0,4,2,0),
#                       plotHeatmaps = FALSE)
# # Plot the heatmap matrix (note: this plot will overwrite the dendrogram plot)
# par(cex = 1.0)
# plotEigengeneNetworks(MET,
#                       "Eigengene adjacency heatmap",
#                       marHeatmap = c(10,10,1,2),
#                       plotDendrograms = FALSE,
#                       xLabelsAngle = 90)

# set the module of interest
module <- "brown"

# Rename to moduleColors if merged
moduleColors <- dynamicColours
column <- match(module, modNames)
moduleGenes <- moduleColors==module
sizeGrWindow(7, 7);
par(mfrow = c(1,1));
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
                   abs(geneTraitSignificance[moduleGenes, 1]),
                   xlab = paste("Module Membership in", module, "module"),
                   ylab = paste("Gene significance for ", name_traitOfInterest),
                   main = paste("Module membership vs. gene significance\n"),
                   cex.main = 1.2,
                   cex.lab = 1.2,
                   cex.axis = 1.2,
                   col = "black")



```

## Merged

```{r}
# select the required module
module <- "brown"
# select the required trait
name_traitOfInterest <- "CD14..Monocytes"
# pull the trait value (eg the cell-type proportion or the BMI of the sample)
traitOfInterest <- traitsAll %>%
  pull(!!sym(name_traitOfInterest)) %>%
  as.data.frame()
# Rename the column for clarity
names(traitOfInterest) <- name_traitOfInterest

# Extract module names from the Module Eigengenes (MEs) object
modNames <- substring(names(mergedMEs), 3)

# Combine Module Eigengenes (MEs) with traitOfInterest data
# note the orderMEs function orders the combined data for better visualization
MET <- orderMEs(cbind(mergedMEs, traitOfInterest))

# Calculate Gene Module Membership (correlation between gene expression and module eigengenes)
geneModuleMembership <- as.data.frame(cor(datExpr, mergedMEs, use = "p"))
# Calculate p-values for the Gene Module Membership correlations
MMPvalue <- as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples))

# Rename columns in geneModuleMembership and MMPvalue for clarity (MM = Module Membership, p.MM = p-value Module Membership)
names(geneModuleMembership) <- paste("MM", modNames, sep="")
names(MMPvalue) <- paste("p.MM", modNames, sep="")

# Calculate Gene Trait Significance (correlation between gene expression and traitOfInterest trait)
geneTraitSignificance = as.data.frame(cor(datExpr, traitOfInterest, use = "p"))
# Calculate p-values for the Gene Trait Significance correlations
GSPvalue <- as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))

# Rename columns in geneTraitSignificance and GSPvalue for clarity (GS = Gene Significance, p.GS = p-value Gene Significance)
names(geneTraitSignificance) <- paste("GS.", names(traitOfInterest), sep="")
names(GSPvalue) <- paste("p.GS.", names(traitOfInterest), sep="")

# Plot the dendrogram
sizeGrWindow(6,6)
par(cex = 1.0)
plotEigengeneNetworks(MET,
                      "Eigengene dendrogram",
                      marDendro = c(0,4,2,0),
                      plotHeatmaps = FALSE)
# Plot the heatmap matrix (note: this plot will overwrite the dendrogram plot)
par(cex = 1.0)
plotEigengeneNetworks(MET,
                      "Eigengene adjacency heatmap",
                      marHeatmap = c(10,10,1,2),
                      plotDendrograms = FALSE,
                      xLabelsAngle = 90)

# Rename to moduleColors if merged
moduleColors <- mergedColours
column <- match(module, modNames)
moduleGenes <- moduleColors==module
sizeGrWindow(7, 7);
par(mfrow = c(1,1));
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
                   abs(geneTraitSignificance[moduleGenes, 1]),
                   xlab = paste("Module Membership in", module, "module"),
                   ylab = paste("Gene significance for ", name_traitOfInterest),
                   main = paste("Module membership vs. gene significance\n"),
                   cex.main = 1.2,
                   cex.lab = 1.2,
                   cex.axis = 1.2,
                   col = "black")

```

# Intramodular connectivity
- To identify structurally central genes driving the networkâ€™s topology within a module.  
```{r}
# calculate kIM
kIM <- intramodularConnectivity(adjMat = adjacency,
                                colors = mergedColours)

# Create a data frame combining the kIM results and module colors
kIM_with_modules <- data.frame(
  Gene = rownames(kIM),      # Add gene names as a column
  Module = mergedColours,     # Add module assignments
  kIM                        # Add the connectivity metrics
)

# create a function to get hub genes for any module
get_hub_genes <- function(kIM_data, module_color, n = 10) {
    # Filter for the specified module
    module_hub_genes <- kIM_data[kIM_data$Module == module_color, ]
    
    # Sort by kWithin in descending order
    module_hub_genes <- module_hub_genes[order(module_hub_genes$kWithin, decreasing = TRUE), ]
    
    # Return top n genes (default is 6)
    return(head(module_hub_genes, n))
}

# use the function to create objects for each module
brown_genes <- get_hub_genes(kIM_with_modules, "brown")
cyan_genes <- get_hub_genes(kIM_with_modules, "cyan")
black_genes <- get_hub_genes(kIM_with_modules, "black")
salmon_genes <- get_hub_genes(kIM_with_modules, "salmon")
grey60_genes <- get_hub_genes(kIM_with_modules, "grey60")
red_genes <- get_hub_genes(kIM_with_modules, "red")
purple_genes <- get_hub_genes(kIM_with_modules, "purple")
tan_genes <- get_hub_genes(kIM_with_modules, "tan")
grey_genes <- get_hub_genes(kIM_with_modules, "grey")
```


```{r}
## Draw bubble plot for particular module

# Calculate column sums of traitsAll and prepare data for merging
colsum_traitsAll <- colSums(traitsAll)
colsum_traitsAll <- data.frame(colsum_traitsAll)
colsum_traitsAll$b_order <- rownames(colsum_traitsAll)

# Prepare moduleTraitCor data for long format
moduleTraitCor_long <- data.frame(moduleTraitCor)
moduleTraitCor_long$module <- rownames(moduleTraitCor)
moduleTraitCor_long <- moduleTraitCor_long[,c(14,1:13)]
# Check column names to ensure they exist
colnames(moduleTraitCor_long)

# Convert moduleTraitCor_long to long format using pivot_longer
moduleTraitCor_long <- moduleTraitCor_long %>%
  pivot_longer(cols = Fetal.Mesenchymal.Stem.Cells:Fetal.Extravillous.Trophoblasts, 
               names_to = "b_order", 
               values_to = "PCC")

# Prepare moduleTraitPvalue data for long format
moduleTraitPvalue_long <- data.frame(moduleTraitPvalue)
moduleTraitPvalue_long$module <- rownames(moduleTraitPvalue)
moduleTraitPvalue_long <- moduleTraitPvalue_long[,c(14,1:13)]
# Convert moduleTraitPvalue_long to long format using gather
moduleTraitPvalue_long <- gather(moduleTraitPvalue_long,
                                 b_order,
                                 pval,
                                 Fetal.Mesenchymal.Stem.Cells:Fetal.Extravillous.Trophoblasts,
                                 factor_key = TRUE)

# Merge correlation and p-value data
moduleTrait_long <- merge(moduleTraitCor_long, moduleTraitPvalue_long, by = c("module","b_order"))
# Merge with column sums data
bubble_Data <- merge(moduleTrait_long, colsum_traitsAll, by = "b_order")

# Filter data for yellow module only
bubble_Data_yellow <- bubble_Data[which(bubble_Data$module == "MEgreenyellow"),]

ggplot(bubble_Data_yellow, aes(x = colsum_traitsAll,
                                   y = PCC,
                                   size = colsum_traitsAll,
                                   color = PCC,
                                   label = b_order)) +
  geom_text(hjust = 1, size = 3) +
  geom_point(alpha = 1) +
  ylab("Module-celltype correlation") +
  xlab("Relative abundance (cell-type proportion sum)") +
  ggtitle(paste("Module:", module))
  theme_bw()
```

# Plot expression of module genes
## un-merged modules
```{r}

# First, let's order filtered_metaData by sex_outcome in ascending order
ordered_metadata <- filtered_metadata[order(filtered_metadata$sex_outcome), ]

# Mean center the log2 cpm data
datExpr_meanCentred <- scale(datExpr, center = TRUE, scale = FALSE)


# Now, we'll reorder datExpr based on the new order of samples in ordered_metaData
datExpr_ordered <- datExpr_meanCentred[ordered_metadata$samplename, ]

# Verify that the order is correct
all(rownames(datExpr_ordered) == ordered_metadata$samplename)  # This should return TRUE

# If you need to ensure datExpr is a matrix (in case it was converted to a data frame)
datExpr_ordered <- as.matrix(datExpr_ordered)


plot_wgcna_modules <- function(expression_matrix, gene_module_table, output_dir = "module_plots") {
  # Create output directory if it doesn't exist
  if (!dir.exists(output_dir)) {
    dir.create(output_dir)
  }
  
  # Create a factor for sample names in the original order
  sample_order <- factor(rownames(expression_matrix), levels = rownames(expression_matrix))
  
  # Reshape the expression matrix
  expr_long <- expression_matrix %>%
    as.data.frame() %>%
    rownames_to_column("Sample") %>%
    pivot_longer(cols = -Sample,
                 names_to = "Gene",
                 values_to = "Expression") %>%
    mutate(Sample = factor(Sample, levels = rownames(expression_matrix)))  # Ensure correct sample order
  
  # Merge with gene_module_table to get module information
  expr_long <- merge(expr_long, gene_module_table, by = "Gene")
  
  # Get unique modules
  modules <- unique(gene_module_table$Module)
  
  # Create a plot for each module
  for (module in modules) {
    # Filter the data for the current module
    module_data <- expr_long %>% filter(Module == module)
    
    # Generate the plot
    p <- ggplot(module_data, aes(x = Sample,
                                 y = Expression,
                                 group = Gene,
                                 color = "red")) +  # Use Gene for line coloring
      geom_line(alpha = 0.5) +
      theme_minimal() +
      theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
            legend.position = "none") +  # Remove legend
      labs(title = paste("Gene Expression in Module", module),
           x = "Samplename",
           y = "Log2 CPM") +
      scale_x_discrete(limits = levels(sample_order))
    
    # Save the plot to the output directory
    ggsave(filename = file.path(outdir, paste0("module_", module, "_linePlot.png")),
           plot = p,
           width = 10,
           height = 6)
  }
  
  cat("Plots have been saved in the", outdir, "directory.\n")
}

# Usage example:
plot_wgcna_modules(datExpr_ordered, gene_module_table)

```

## merged modules
```{r}

# First, let's order filtered_metaData by sex_outcome in ascending order
ordered_metadata <- filtered_metadata[order(filtered_metadata$sex_outcome), ]

# Mean center the log2 cpm data
datExpr_meanCentred <- scale(datExpr, center = TRUE, scale = FALSE)


# Now, we'll reorder datExpr based on the new order of samples in ordered_metaData
datExpr_ordered <- datExpr_meanCentred[ordered_metadata$samplename, ]

# Verify that the order is correct
all(rownames(datExpr_ordered) == ordered_metadata$samplename)  # This should return TRUE

# ensure datExpr is a matrix (in case it was converted to a data frame)
datExpr_ordered <- as.matrix(datExpr_ordered)


plot_wgcna_modules <- function(expression_matrix, gene_module_table, output_dir = "module_plots") {
  # Create output directory if it doesn't exist
  if (!dir.exists(output_dir)) {
    dir.create(output_dir)
  }
  
  # Create a factor for sample names in the original order
  sample_order <- factor(rownames(expression_matrix), levels = rownames(expression_matrix))
  
  # Reshape the expression matrix
  expr_long <- expression_matrix %>%
    as.data.frame() %>%
    rownames_to_column("Sample") %>%
    pivot_longer(cols = -Sample,
                 names_to = "Gene",
                 values_to = "Expression") %>%
    mutate(Sample = factor(Sample, levels = rownames(expression_matrix)))  # Ensure correct sample order
  
  # Merge with gene_module_table to get module information
  expr_long <- merge(expr_long, gene_module_table, by = "Gene")
  
  # Get unique modules
  modules <- unique(gene_module_table$Module)
  
  # Create a plot for each module
  for (module in modules) {
    # Filter the data for the current module
    module_data <- expr_long %>% filter(Module == module)
    
    # Generate the plot
    p <- ggplot(module_data, aes(x = Sample,
                                 y = Expression,
                                 group = Gene,
                                 color = "red")) +  # Use Gene for line coloring
      geom_line(alpha = 0.5) +
      theme_minimal() +
      theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
            legend.position = "none") +  # Remove legend
      labs(title = paste("Gene Expression in Module", module),
           x = "Samplename",
           y = "Log2 CPM") +
      scale_x_discrete(limits = levels(sample_order))
    
    # Save the plot to the output directory
    ggsave(filename = file.path(outdir, paste0("mergedModule_", module, "_linePlot.png")),
           plot = p,
           width = 10,
           height = 6)
  }
  
  cat("Plots have been saved in the", outdir, "directory.\n")
}

# Usage example:
plot_wgcna_modules(datExpr_ordered, merged_gene_module_table)

```

# Table data
## un-merged modules
```{r}
# dynamicColours

# Calculate the proportion of variation (in each module) explained by the eigengene
propExp <- propVarExplained(datExpr = datExpr,
                            colors = dynamicColours,
                            MEs = MEs,
                            corFnc = "bicor",
                            corOptions = "use = 'p'")

# find the hub gene for each module
topHubGenes <- chooseTopHubInEachModule(datExpr = datExpr,
                                        colorh = dynamicColours,
                                        omitColors = "grey",
                                        power = 2,
                                        type = "signed")

# calculate the kME (module membership) for each gene
kME <- signedKME(datExpr = datExpr,
                 datME = MEs,
                 exprWeights = NULL,
                 MEWeights = NULL,
                 outputColumnName = "kME_",
                 corFnc = "bicor",
                 corOptions = "use = 'p'") %>%
  tibble::rownames_to_column("hgnc_symbol") %>%
  # add the gene and DE information
  left_join(., allTable_male, by = "hgnc_symbol") %>%
  dplyr::select(., hgnc_symbol, ensembl, chromosome = seqnames,
                gene_type, logFC, adj.P.Val, kME_black , kME_blue, kME_brown, kME_green, kME_greenyellow,
                kME_grey, kME_magenta, kME_pink, kME_purple, kME_red, kME_salmon, kME_tan, kME_turquoise, kME_yellow)


# Sort by module in descending order and select the top 10 rows
top10_hgnc <- kME %>%
  dplyr::arrange(desc(kME_black)) %>%  # Sort descending by kMEbrown
  dplyr::slice(1:10) %>%              # Select top 10 rows
  dplyr::pull(hgnc_symbol)            # Return hgnc_symbol column


connectivityGenes <- intramodularConnectivity(adjMat = adjacency,
                         colors = dynamicColours,
                         scaleByMax = FALSE)

topHubGenesTotal <- cbind(Gene = colnames(adjacency), 
                          Module = dynamicColours, 
                          Connectivity = connectivityGenes) %>%
  tbl_df() %>%
  arrange(desc(Connectivity.kTotal)) %>%
  distinct(Module, .keep_all = TRUE) %>%
  dplyr::select(-Connectivity.kOut, -Connectivity.kDiff)

topHubGenesInModule <- cbind(Gene = colnames(adjacency), 
                             Module = dynamicColours, 
                             Connectivity = connectivityGenes) %>%
  tbl_df() %>%
  arrange(desc(Connectivity.kWithin)) %>%
  distinct(Module, .keep_all = TRUE) %>%
  dplyr::select(-Connectivity.kOut, -Connectivity.kDiff) %>%
  distinct(Gene, .keep_all = TRUE)

```

## Merged modules

```{r}
# Calculate the proportion of variation (in each module) explained by the eigengene
propExp <- propVarExplained(datExpr = datExpr,
                            colors = mergedColours,
                            MEs = mergedMEs,
                            corFnc = "bicor",
                            corOptions = "use = 'p'") %>%
  as.data.frame()

# calculate the kME (module membership) for each gene
kME <- signedKME(datExpr = datExpr,
                 datME = mergedMEs,
                 exprWeights = NULL,
                 MEWeights = NULL,
                 outputColumnName = "kME_",
                 corFnc = "bicor",
                 corOptions = "use = 'p'")

# Find genes in the top 10 kME for multiple modules, including module names
top_genes <- setNames(lapply(unique(mergedColours), function(module) {
  # Select genes in the current module
  genes_in_module <- rownames(kME)[mergedColours == module]
  
  # Sort genes by kME and select the top 10
  top_genes_in_module <- genes_in_module[order(kME[genes_in_module, paste0("kME_", module)], decreasing = TRUE)[1:10]]
  
  return(top_genes_in_module)
}), unique(mergedColours)) # Name each list element by the module color

# Check for overlaps
top_genes_overlap <- Reduce(intersect, top_genes)
print(top_genes_overlap)


# find the hub gene for each module
topHubGene <- chooseTopHubInEachModule(datExpr = datExpr,
                                        colorh = mergedColours,
                                        omitColors = "grey",
                                        power = 2,
                                        type = "signed") %>%
  as.data.frame()


```

# Fischer's exact test for enrichment of X, Y genes per module
- broad brush look at the module genes

```{r}
chromosome_module <- dplyr::left_join(gene_module_table, dplyr::select(allTable_male, Gene = hgnc_symbol, seqnames), by = "Gene")

# Extract chromosome information from seq_names
chromosome_module$chromosome <- str_extract(chromosome_module$seqnames, "chr\\d+|chrX|chrY|chrM")

# Function to perform Fisher's exact test for a single module and chromosome
perform_fishers_test <- function(data, module, chrom) {
  contingency_table <- table(
    data$Module == module,
    data$chromosome == chrom
  )
  fisher.test(contingency_table)
}

# Get unique modules and chromosomes
unique_modules <- unique(chromosome_module$Module)
unique_chromosomes <- unique(chromosome_module$chromosome)

# Perform Fisher's exact test for each module-chromosome combination
results_allChr <- expand.grid(module = unique_modules, chromosome = unique_chromosomes) %>%
  rowwise() %>%
  mutate(
    p_value = perform_fishers_test(chromosome_module, module, chromosome)$p.value,
    odds_ratio = perform_fishers_test(chromosome_module, module, chromosome)$estimate
  )

# Adjust p-values for multiple testing
results_allChr$adjusted_p_value <- p.adjust(results_allChr$p_value, method = "BH")

# Sort results by adjusted p-value
results_allChr_sorted <- results_allChr %>%
  arrange(adjusted_p_value)

# Print top 10 most significant results
print(head(results_allChr_sorted, 10))


# Perform Fisher's exact test for each module-chromosome combination
results_sexChr <- expand.grid(module = unique_modules, chromosome = c("chrX", "chrY")) %>%
  rowwise() %>%
  mutate(
    p_value = perform_fishers_test(chromosome_module, module, chromosome)$p.value,
    odds_ratio = perform_fishers_test(chromosome_module, module, chromosome)$estimate
  )

# Adjust p-values for multiple testing
results_sexChr$adjusted_p_value <- p.adjust(results_sexChr$p_value, method = "BH")

# Sort results by adjusted p-value
results_sexChr_sorted <- results_sexChr %>%
  arrange(adjusted_p_value)

# Print top 10 most significant results
print(head(results_sexChr_sorted, 10))
# Optional: Save results to a CSV file
# write.csv(results_sorted, "fishers_exact_test_results.csv", row.names = FALSE)
```


# test cell-type proportions differences
- this uses the beta regression suggested in the Campbell et al. paper  
```{r}
# perform beta regression to determine if there are cell-type differences based on outcome
# with columns for cell types, case_control, fetal_sex, and gestational_age

# Function to perform beta regression for a single cell type
# Load required libraries
library(betareg)
library(tidyverse)
library(broom)

# Function to perform beta regression for a single cell type
perform_beta_regression <- function(cell_type, data) {
  # Transform data to ensure all values are between 0 and 1
  data[[cell_type]] <- (data[[cell_type]] * (nrow(data) - 1) + 0.5) / nrow(data)
  
  formula <- as.formula(paste(cell_type, "~ Outcome + GestationalAge"))
  
  tryCatch({
    model <- betareg(formula, data = data)
    
    # Extract results
    results <- tidy(model) %>%
      filter(term == "OutcomePE") %>%
      mutate(cell_type = cell_type,
             odds_ratio = exp(estimate),
             ci_lower = exp(estimate - 1.96 * std.error),
             ci_upper = exp(estimate + 1.96 * std.error))
    
    return(results)
  }, error = function(e) {
    warning(paste("Error in cell type:", cell_type, "- ", e$message))
    return(NULL)
  })
}

# List of cell type columns
cell_types <- c("Fetal.Mesenchymal.Stem.Cells", "CD14..Monocytes", "CD8..Activated.T.Cells", "Naive.CD4..T.Cells",
                "Naive.CD8..T.Cells", "Natural.Killer.T.Cells", "B.Cells", "Fetal.GZMK..Natural.Killer", "Fetal.Memory.CD4..T.Cells",
                "Fetal.Hofbauer.Cells", "Fetal.Plasmacytoid.Dendritic.Cells", "Fetal.GZMB..Natural.Killer", "Fetal.Endothelial.Cells",
                "Fetal.Syncytiotrophoblast", "Fetal.Fibroblasts", "Cytotrophoblast", "Fetal.Nucleated.Red.Blood.Cells", "Maternal.FCGR3A..Monocytes",
                "Maternal.Plasma.Cells", "Fetal.Extravillous.Trophoblasts")

# Prepare the data
df <- dplyr::left_join(filtered_metadata, deduplicated_cibersortx_adjusted, by = "samplename") %>%
  dplyr::select(all_of(c(cell_types, "Outcome", "GestationalAge")))

# Check for any NAs or infinite values
df <- df %>% drop_na()

# Perform beta regression for each cell type
results_list <- lapply(cell_types, perform_beta_regression, data = df)

# Remove NULL results (if any errors occurred)
results_list <- results_list[!sapply(results_list, is.null)]

# Combine results
final_results <- bind_rows(results_list)

# View results
print(final_results)

final_results <- final_results %>%
  mutate(
    significant = (ci_lower > 1 | ci_upper < 1),
    direction = case_when(
      odds_ratio > 1 & significant ~ "Higher in PE",
      odds_ratio < 1 & significant ~ "Lower in PE",
      TRUE ~ "No significant difference"
    )
  )

# Updated ggplot code
ggplot(final_results, aes(x = reorder(cell_type, odds_ratio), y = odds_ratio)) +
  geom_point(aes(color = direction), size = 3) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper, color = direction), width = 0.2) +
  coord_flip() +
  geom_hline(yintercept = 1, linetype = "dashed") +
  scale_color_manual(values = c("Higher in PE" = "red", "Lower in PE" = "blue", "No significant difference" = "gray")) +
  scale_y_log10() +  # Use log scale for better visualization of ratios
  labs(title = "Odds Ratios for Cell Type Proportions in Preeclampsia",
       x = "Cell Type",
       y = "Odds Ratio (95% CI, log scale)",
       color = "Association with PE") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 8),
        legend.position = "bottom")

# If you want to save the plot
# ggsave("cell_type_odds_ratios_PE.png", width = 12, height = 10, dpi = 300)

# Print a summary table
summary_table <- final_results %>%
  select(cell_type, odds_ratio, ci_lower, ci_upper, direction) %>%
  arrange(desc(odds_ratio))

print(summary_table)
```






